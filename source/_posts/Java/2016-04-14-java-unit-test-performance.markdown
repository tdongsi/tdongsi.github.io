---
layout: post
title: "Java: unit test performance"
date: 2016-05-14 22:47:42 -0700
comments: true
categories: 
- Java
- Jenkins
- JMockit
- TestNG
- Testing
- Maven
---

it wasn’t productive for developers to wait 30mins+ to verify tests locally, especially when we have multiple checkins per day. In addition, the run time gets compounded with additive increases to unit tests.

So, I took this as a whitespace opportunity and made following changes in the unit-test project to reduce the time to more than half.  Also, I've pointed out few recommendations too based on my fixes.

Removed all the Sytem.out.println statements from the test classes. The logs don't matter when we're running in parallel and moreover it was adding 5-10 mins to the build time irrelevant of running in sequential or parallel. --So, please don’t add logs to your tests

Some tests started failing with the above change as it was overriding the default System.out by calling System.setOut(PrintStream) and verifying the test result by asserting against log statements. I modified such tests to use Jmockit Verifications feature and not relying on output generated by logs. --For Behavior-based testing, please use Jmockit Verifications and do not depend on output of logs generated by the class being tested

We had around 100s of tests that were throwing "Exception encountered, logging will be disabled". After little debugging I noticed, these are the exceptions thrown by Jmockit while instrumenting. Mocked Log in all the test classes that were throwing exception and added stubOutClassInitialization=true while mocking as below if there is static initialization code in the class -- Mock Log and Config classes if applicable

Use (stubOutClassInitialization = true) if the mocked class has any static initialization block.
TODO: Add lin to previous blog.

Some test classes were really big which contained  >150 tests and hence were taking 6-7 mins. As we're running classes in parallel across multiple JVMs, I noticed all the JVMs were shut down except 1-2 which were running these classes. So, I had to split those classes into multiple classes to distribute the load equally across multiple JVMs. - Break your test class into multiple classes if having large no. of tests.

Out of all the maven-surefire options for running tests in parallel, the one that worked considering Jmockit limitations with parallel execution and our tests structure are as below. However, I had to fix all the above issues to be able to run faster with below parallel config.

``` xml Maven-surefire option
<parallel>classes</parallel>
<forkCount>${forkCount}</forkCount>
<reuseForks>false</resuseForks>
```

How to run on local? run below command.

``` plain
mvn test –P parallel 
```

By default,  the above command runs with 6 JVMS, but if you want to experiment with more JVMS, you can configure as below. For ex. To run with 10 JVMS

``` plain
mvn test –P parallel –DforkCount=10
```
