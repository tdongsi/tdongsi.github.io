<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Bash | Personal Programming Notes]]></title>
  <link href="http://tdongsi.github.io/blog/categories/bash/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/"/>
  <updated>2017-07-11T10:11:43-07:00</updated>
  <id>http://tdongsi.github.io/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bash Trap]]></title>
    <link href="http://tdongsi.github.io/blog/2016/03/02/bash-trap/"/>
    <updated>2016-03-02T00:07:48-08:00</updated>
    <id>http://tdongsi.github.io/blog/2016/03/02/bash-trap</id>
    <content type="html"><![CDATA[<p>In this post, we discuss common usage of bash <code>trap</code> to ensure proper cleanup operations in Bash scripts.
It also discusses a common idiom <code>trap cleanup INT TERM EXIT</code> where other signals such as INT and TERM is also trapped in addition to EXIT.
While such idiom could be valid in some Unix system, it is usually redundant and can be simply wrong (duplicate executions) in most cases, as shown on Mac.
A simple test is provided to verify if such idiom is applicable in your current system.</p>

<!--more-->


<h3>Standard usage</h3>

<p>There is a simple idiom to ensure your bash scripts to always do proper cleanup operations before exiting, even when something goes wrong during execution.
In the context of Java or Python, this is similar to a <code>finally</code> clause that will execute after any exception is caught during execution.</p>

<pre><code class="bash DO THIS"># Setup trap to cleanup before exiting script
function cleanup {
    echo "Removing temp files..."
    if [[ -f $CMD_TMPFILE ]] ; then
        rm $CMD_TMPFILE
    fi
    if [[ -f $LOG_TMPFILE ]] ; then
        rm $LOG_TMPFILE
    fi
}
trap cleanup EXIT

# Setup

# Thousand lines of code here
</code></pre>

<p>Putting the cleanup operations at the end of the bash script might not work in cases of error.
Since the bash script already stops executing due to some fatal error, those clean up commands might never run.</p>

<pre><code class="bash DON'T DO THIS">
# Setup

# Thousand lines of code here

# This might not run when there is error
echo "Removing temp files..."
if [[ -f $CMD_TMPFILE ]] ; then
    rm $CMD_TMPFILE
fi
if [[ -f $LOG_TMPFILE ]] ; then
    rm $LOG_TMPFILE
fi
</code></pre>

<p>For example, in Vertica, you should always run <a href="https://my.vertica.com/docs/7.1.x/HTML/Content/Authoring/SQLReferenceManual/Functions/VerticaFunctions/START_REFRESH.htm"><code>SELECT START_REFRESH()</code></a>
at the end of a deployment script, regardless of any error encountered during script execution.
It is a good candidate for using <code>trap</code> statement.
Adding those commands at the end of the script will not work in cases there is an error during deployment, and you might end up with &ldquo;AHM Does Not Advance&rdquo;-related errors (see this <a href="/blog/2016/02/29/vertica-9-refresh-projections/">post</a>).</p>

<h3>Trap multiple signals</h3>

<p>Note that many online examples for <code>trap</code> use a list of signals for cleanup tasks like this <code>trap cleanup INT TERM EXIT</code>, i.e., trapping not only EXIT signal but also INT and TERM signals.
I believe that if <code>EXIT</code> signal is used, other signals such as <code>INT</code> or <code>TERM</code> are redundant for cleanup purposes.
<code>EXIT</code> or 0 signal is invoked when the shell exits, an event that also happens when an <code>INT</code> or <code>TERM</code> signal is received.
It is easy to confirm that with the following short bash script:</p>

<pre><code class="plain Trap tests in Mac OSX">MTVL1288aeea2-82:code tdongsi$ cat test_trap.sh
#!/bin/bash
trap 'echo SIGNAL CAPTURED' EXIT
sleep 3

MTVL1288aeea2-82:code tdongsi$ ./test_trap.sh &amp; sleep 1; kill -INT %1
[1] 6613
SIGNAL CAPTURED
[1]+  Interrupt: 2            ./test_trap.sh

MTVL1288aeea2-82:code tdongsi$ ./test_trap.sh &amp; sleep 1; kill -TERM %1
[1] 6624
SIGNAL CAPTURED
[1]+  Terminated: 15          ./test_trap.sh
</code></pre>

<p>As shown above, a lone <code>EXIT</code> is enough to capture <code>INT</code> and <code>TERM</code> signals.
Having said that, I understand that my tests can only verify bash on Mac OSX.
There are probably different shell variants on different operating systems which do not always work that way.</p>

<p>The problem of those <code>trap</code> examples lies in when someone copies and uses the code directly from the web, without understanding how it works.
Listing multiple signals can make the <code>cleanup</code> steps executed twice, once for the signal such as <code>TERM</code> and once for <code>EXIT</code>, as shown in the modified experiment below.
Not all cleanup steps could be and should be executed twice.
For example, it is almost always true that removing some temporary file/folder should not be executed twice during a cleanup.</p>

<pre><code class="plain Problem of trapping multiple signals">MTVL1288aeea2-82:code tdongsi$ cat test_trap.sh
#!/bin/bash
trap 'echo SIGNAL CAPTURED' INT TERM EXIT
sleep 3

MTVL1288aeea2-82:code tdongsi$ ./test_trap.sh &amp; sleep 1; kill -INT %1
[1] 7258
SIGNAL CAPTURED
SIGNAL CAPTURED
[1]+  Exit 130                ./test_trap.sh

MTVL1288aeea2-82:code tdongsi$ ./test_trap.sh &amp; sleep 1; kill -TERM %1
[1] 7278
Terminated: 15
SIGNAL CAPTURED
SIGNAL CAPTURED
[1]+  Exit 143                ./test_trap.sh
</code></pre>

<p>In short, you should know how <code>trap</code> works on your production system before listing multiple signals as its parameters, especially when coupled with <code>EXIT</code> signal.</p>

<h3>Other usage notes</h3>

<p>The signal names might be specified with or without prefix <code>SIG</code> or even with numeric values for signal numbers, e.g., 2 for INT (see list below).</p>

<pre><code class="plain List of signals">MTVL1288aeea2-82:octopress tdongsi$ kill -l
 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL
 5) SIGTRAP  6) SIGABRT  7) SIGEMT   8) SIGFPE
 9) SIGKILL 10) SIGBUS  11) SIGSEGV 12) SIGSYS
13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGURG
17) SIGSTOP 18) SIGTSTP 19) SIGCONT 20) SIGCHLD
21) SIGTTIN 22) SIGTTOU 23) SIGIO   24) SIGXCPU
25) SIGXFSZ 26) SIGVTALRM   27) SIGPROF 28) SIGWINCH
29) SIGINFO 30) SIGUSR1 31) SIGUSR2

OR 

MTVL1288aeea2-82:octopress tdongsi$ man signal
</code></pre>

<p>If one of the signals specified in <code>trap</code> statement is <code>DEBUG</code>, the list of COMMANDS specified in <code>trap</code> statement will be executed after every simple command.
This is useful for debugging purpose.
The following example is taken from <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_12.html">here</a>:</p>

<pre><code class="bash Tracing when a variable is used">declare -t VARIABLE=value
trap "echo VARIABLE is being used here." DEBUG

# rest of the script
</code></pre>

<h3>References</h3>

<ol>
<li><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/chap_12.html">Signals and Traps</a></li>
<li><a href="http://redsymbol.net/articles/bash-exit-traps/">Other usages</a></li>
<li><a href="http://wiki.bash-hackers.org/commands/builtin/declare">declare</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Symlinks in Git]]></title>
    <link href="http://tdongsi.github.io/blog/2016/02/20/symlinks-in-git/"/>
    <updated>2016-02-20T11:28:11-08:00</updated>
    <id>http://tdongsi.github.io/blog/2016/02/20/symlinks-in-git</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s say we have folders with many symbolic links in them, linking to other files in the same Git repository.</p>

<pre><code class="bash Before">$ ls -l link
... link -&gt; /path/to/target
</code></pre>

<p>Unfortunately after committing into Git, they&rsquo;ve turned into plain text files.
Note that even after committing and pushing into Git, the symlinks still work fine.
However, after some branch switches and code merges, the symlinks become actual text files with the link target as the contents.</p>

<pre><code class="bash After">$ cat link
/path/to/target
</code></pre>

<!--more-->


<h3>Restoring the symlinks</h3>

<p>Before going into lengthy discussion on how Git handles symlinks and hard links, the quick solution for the above problem is the following Bash script:</p>

<pre><code class="bash">folder=/Users/tdongsi/Github/my_repo/scripts/sql
ls -d1 $folder/* | while read f; do
  ln -sf "$(cat $f)" "$f"
done
</code></pre>

<p>where <code>ls -d1 $folder/*</code> should be replaced with some command that will list exactly the files you want, preferably in full path.
Note that <code>-f</code> option of <code>ln</code> command is required to replace the file with the symlink. For examples:</p>

<pre><code class="bash Examples">ls -d1 vertica/*.sql | while read f; do
  ln -sf "$(cat $f)" "$f"
done

ls -d1 bash/* | while read f; do
  ln -sf "$(cat $f)" "$f"
done
</code></pre>

<p><strong>Best practice note</strong>: I think that the following template is preferred to the more commonly seen <code>for f in $(ls *);</code> <code>do...done</code>:</p>

<pre><code class="bash">ls * | while read f; do
  # command executed for each file
done
</code></pre>

<p>I think it is the better way to handle all file names, especially with spaces, since <code>"$f"</code> will still work.
In addition, <code>$(cmd)</code> is the same as <code>'cmd'</code> (backticks) but it can be nested, unlike using backticks.
It fact, it&rsquo;s the main reason why the backticks have been <a href="http://wiki.bash-hackers.org/scripting/obsolete">deprecated</a> from Bash scripting.</p>

<h3>How Git deals with symlinks</h3>

<p>How Git deals with symlinks is defined in the <a href="https://git-scm.com/docs/git-config">git config</a> <code>core.symlinks</code>.
If false, symbolic links are checked out as small plain files that contain the link text.
<a href="http://stackoverflow.com/questions/954560/how-does-git-handle-symbolic-links">Otherwise</a>, Git just stores the contents of the link (i.e., the path of the file system) in a &lsquo;blob&rsquo; just like it would for a normal file.
It also stores the name, mode and type (e.g., symlink) in the tree object that represents its containing directory.
When you checkout a tree containing the link, it restores the object as a symlink.</p>

<p>After the symlinks are checked out as plain text files, I believe it is pretty much no way for Git to restore symlinks again (i.e., follow symlinks inside text files).
It would be an insecure, undefined behavior: what if the symlink as text file is modified? What if the target is changed when moving between versions of that text file?</p>

<h3>Use hard links?</h3>

<p>You can use hard links instead of symlinks (a.k.a., soft links).
Git will handle a hard link like a copy of the file, except that the contents of the linked files change at the same time.
Git may see changes in both files if both the original file and the hard link are in the same repository.</p>

<p>One of the disadvantages is that the file will be created as a normal file during <code>git checkout</code>, because there is no way Git understand it as a link.
Moreover, hard link itself has many limitations, compared to symlinks, such as files have to reside on the same file-system or partition.
In Mac OSX, hard links to directories are not supported. There is a <a href="https://github.com/selkhateeb/hardlink">tool</a> to do that, but use it with caution.</p>

<p>Finally, it is important to note that hard links to files can be lost when moving between different versions/branches in Git, even if they are in the same repository.
When you switch branches back and forth, Git remove the old files and create new ones.
You still have the copies of the previous files, but they might have totally different inodes, while others (if not in the same Git repo) still refers to the old inodes.
Eventually, the file and its hard links may be out of sync, and appear like totally unrelated files to Git.
Therefore, using hard links, at best, is just a temporary solution.</p>

<h3>Links</h3>

<ol>
<li><a href="http://superuser.com/questions/638998/easiest-way-to-restore-symbolic-links-turned-into-text-files">Alternative ways to restore symlinks</a></li>
<li><a href="http://stackoverflow.com/questions/246215/how-can-i-list-files-with-their-absolute-path-in-linux">Alternative ways to list files</a></li>
<li><a href="https://git.wiki.kernel.org/index.php/Git">Git design overview</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Virtual Machine for ETL Testing]]></title>
    <link href="http://tdongsi.github.io/blog/2016/01/10/find-and-replace-a-string-in-multiple-files/"/>
    <updated>2016-01-10T23:49:15-08:00</updated>
    <id>http://tdongsi.github.io/blog/2016/01/10/find-and-replace-a-string-in-multiple-files</id>
    <content type="html"><![CDATA[<h3>Vertica Virtual Machine as sandbox test environment</h3>

<p>When developing data-warehouse solutions in Vertica, you want to set up some test environment.
Ideally, you should have separate schema for each developer.
However, it is usually NOT possible in my experience: developers and test engineers have to share very few schemas in development environment.
The explanation that I usually get is that having a schema for each developer will not scale in database maintenance and administration, and there are likely some limits in Vertica&rsquo;s commercial license.
If that is the case, I recommend that we look into using Vertica Community Edition on <strong>Virtual Machines (VMs)</strong> for sandbox test environment, as a cheap alternative.</p>

<p>Are VMs really necessary in data-warehouse testing? When testing Extract-Transform-Load (ETL) processes, I find that many of test cases require regular set-up and tear-down, adding mock records to force rare logical branches and corner cases, and/or running ETLs multiple times to simulate daily runs of those processes.
Regular tear-down requires dropping multiple tables regularly, which requires much greater care and drains much mental energy when working with others' data and tables.
Similarly, adding mock records into some commonly shared tables might affect others when they assume the data is production-like.
Running ETL scripts regularly, which could be computationally intensive, on a shared Vertica cluster might affect the performance or get affected by others' processes.
In short, for these tests, I cannot use the common schema that is shared with others since it might interfere others and/or destroy valuable common data.
Using a Vertica VM as the sandbox test environment helps us minimize interference to and from others' data and activities.</p>

<h3>Single-node VM and KSAFE clause</h3>

<p>I have been using a <strong>single-node</strong> Vertica VM to run tests for sometime. And it works wonderfully for testing purpose, especially when you want to isolate issues, for example, a corner case. The Vertica VM can be downloaded from HP Vertica&rsquo;s support website (NOTE: As of 2016 Jan 1st, the Vertica 7.1 VM is taken down while the Vertica 7.2 VM is not available).</p>

<p>The only minor problem is when we add <code>KSAFE 1</code> in our DDL scripts (i.e., <code>CREATE TABLE</code> statements) for production purposes. This gives error on single-node VM when running DDL scripts to set up schema.
The reason is that Vertica database with one or two hosts cannot be <em>k-safe</em> (i.e., it may lose data if it crashes) and three-node cluster is the minimum requirement to have <code>KSAFE 1</code> in <code>CREATE TABLE</code> statements to work.</p>

<p>Even then, the workaround for running those DDL scripts in tests is easy enough if all DDL scripts are all located in a single folder. The idea is that since <code>KSAFE 1</code> does not affect ETL processes' transform logics, we can remove those KSAFE clauses to set up the test schema and go ahead with our ETL testing. Specifically, in my project, my workflow for ETL testing with <strong>Git</strong> is as follows:</p>

<ul>
<li>Branch the latest code (<code>develop</code> branch) into a temporary branch (e.g., <code>local/develop</code> branch).</li>
<li>Find and remove <code>KSAFE 1</code> in all DDL files (see subsection below).</li>
<li>While still in <code>local/develop</code> branch, commit all these changes in a <strong>single</strong> commit with some unique description (e.g., &ldquo;KSAFE REMOVAL&rdquo;).</li>
<li>Add unit and functional tests to ETL scripts in this branch.</li>
<li>After tests are properly developed and checked-in, reverse the &ldquo;KSAFE REMOVAL&rdquo; commit above.

<ul>
<li>In SourceTree, it could be done by a simple right-click on that commit and selecting &ldquo;Reverse Commit&rdquo;.</li>
</ul>
</li>
<li>Merge <code>local/develop</code> branch into <code>develop</code> branch (create a pull request if needed). You will now have your tests with the latest codes in <code>develop</code> branch.</li>
</ul>


<h4>Find and replace a string in multiple files</h4>

<p>There are times and times again that you find that you have to replace every single occurrences of some string in multiple files with another string. Finding and removing <code>KSAFE 1</code> like the above workflow is an example where &ldquo;removing string&rdquo; is a special case of &ldquo;replacing string&rdquo; with nothing. This operation can be quickly done by the following bash command:</p>

<pre><code>grep -rl match_string your_dir/ | xargs sed -i 's/old_string/new_string/g'
</code></pre>

<p>If you are familiar with bash scripting, the above command is straight forward. This quick explanation is for anyone who does not understand the command:</p>

<ul>
<li><code>grep</code> command finds all files in <code>your_dir</code> directory that contain <code>match_string</code>. <code>-l</code> option makes sure it will return a list of files</li>
<li><code>sed</code> command then execute the replacement regex on all those files. A regex tip: the forward slash <code>/</code> delimiter could be another delimiter (e.g., <code>#</code>). This might be useful if you need to search HTML files.</li>
</ul>


<p>Example: In my case, all the DDL scripts are in multiple sub-directories under <code>tables</code> directory. To find and remove all <code>KSAFE 1</code> occurrences, the command is:</p>

<pre><code>grep -rl 'KSAFE 1' tables | xargs sed -i 's/KSAFE 1//g'
</code></pre>

<p>This will search for the string <code>KSAFE 1</code> in all files in the <code>tables</code> directory and replace <code>KSAFE 1</code> with nothing <code>''</code> for each occurrence of the string in each file.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH Cookbook: Ssh-add]]></title>
    <link href="http://tdongsi.github.io/blog/2015/05/16/ssh-add-cookbook/"/>
    <updated>2015-05-16T16:38:46-07:00</updated>
    <id>http://tdongsi.github.io/blog/2015/05/16/ssh-add-cookbook</id>
    <content type="html"><![CDATA[<p>Recipes with <code>ssh-add</code> command.</p>

<h3>Simple usages</h3>

<pre><code class="plain Adding identity file">ssh-add /path/to/file/id_rsa.pem
</code></pre>

<pre><code class="plain Listing identities"># Display the keys' fingerprints only
ssh-add -l
# Display same in MD5 format
ssh-add -l -E md5
# Display the entire public key
ssh-add -L
</code></pre>

<pre><code class="plain Deleting identity"># Delete a key
ssh-add -d /path/to/file
# Clear all keys
ssh-add -D
</code></pre>

<h3>OSX specific</h3>

<p>On OS X <code>ssh-add</code> is integrated with the system keychain. If you give the <code>-K</code> option, as in <code>ssh-add -K</code>, when you add a key, that key’s password will be added to the keychain. As long as your keychain is unlocked, a key that has been stored in this way doesn’t require a password to be loaded into the agent.</p>

<p>All keys with their password stored in the keychain will automatically be loaded when you run <code>ssh -A</code>. This happens automatically on login.</p>

<p>When a password has been stored in keychain, <code>ssh -K -d key-file</code> both removes the key from the agent and removes it password from the keychain. Without <code>-K</code>, <code>-d</code> does not change the keychain and the key can be reloaded without a password. <code>-D</code> silently ignores <code>-K</code>.</p>

<h3>Recipe: Connecting without a passphrase</h3>

<p><code>ssh-add</code> is commonly used to simplify <code>ssh</code> command.
In the following example, you need to specify a private key file in some location.</p>

<pre><code class="plain Before">mymac:~ tdongsi$ ssh -i ~/.ssh/private.key centos@k8s-worker-10
Enter passphrase for key '/Users/tdongsi/.ssh/private.key':
Last login: Mon May 15 20:17:13 2017 from 10.3.52.223
[centos@k8s-worker-10 ~]$ exit
logout
Connection to k8s-worker-10 closed.
</code></pre>

<p>By adding the private key to the authentication agent with <code>ssh-add</code>, you can simplify the <code>ssh</code> command as follows:</p>

<pre><code class="plain After">mymac:~ tdongsi$ ssh-add ~/.ssh/private.key
Enter passphrase for /Users/tdongsi/.ssh/private.key:
Identity added: /Users/tdongsi/.ssh/private.key (/Users/tdongsi/.ssh/private.key)
mymac:~ tdongsi$ ssh-add -l
2048 SHA256:WKysqi9jq735mRK0U2MNS5A /Users/tdongsi/.ssh/private.key (RSA)

mymac:~ tdongsi$ ssh centos@k8s-worker-10
Last login: Mon May 15 20:23:46 2017 from 10.10.74.67
[centos@k8s-worker-10 ~]$ exit
</code></pre>

<h3>Reference</h3>

<ul>
<li><a href="https://help.github.com/articles/error-permission-denied-publickey/">ssh-add</a>

<ul>
<li><a href="http://stuff-things.net/2016/02/11/stupid-ssh-add-tricks/">ssh-add tips</a></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH Cookbook: Ssh]]></title>
    <link href="http://tdongsi.github.io/blog/2015/05/11/ssh-cookbook/"/>
    <updated>2015-05-11T13:45:35-07:00</updated>
    <id>http://tdongsi.github.io/blog/2015/05/11/ssh-cookbook</id>
    <content type="html"><![CDATA[<p>This blog lists some recipes that is related to <code>ssh</code> commands.</p>

<h3>Quick recipes</h3>

<p>Recipe 1: <a href="https://askubuntu.com/questions/53553/how-do-i-retrieve-the-public-key-from-a-ssh-private-key">link</a></p>

<pre><code class="plain Recipe 1: Generate public key from private key">ssh-keygen -y -f ~/.ssh/id_rsa &gt; ~/.ssh/id_rsa.pub
</code></pre>

<p>Recipe 2: <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html#verify-key-pair-fingerprints">link</a></p>

<pre><code class="plain Recipe 2: Show fingerprint of the private key in MD5 format (used by Github, AWS)">openssl rsa -in ~/.ssh/id_rsa -pubout -outform DER | openssl md5 -c
</code></pre>

<p>Recipe 3: <a href="https://serverfault.com/questions/132970/can-i-automatically-add-a-new-host-to-known-hosts">link</a>.</p>

<pre><code class="plain Recipe 3: Add new hosts to known_hosts file">ssh-keyscan -H [ip_address] &gt;&gt; ~/.ssh/known_hosts
ssh-keyscan -H [hostname] &gt;&gt; ~/.ssh/known_hosts
</code></pre>

<h3><code>-R</code> and <code>-L</code> of <code>ssh</code></h3>

<p>Those options stands for remote and local port forwarding.
There are blog posts explain these options better than <a href="https://unix.stackexchange.com/questions/115897/whats-ssh-port-forwarding-and-whats-the-difference-between-ssh-local-and-remot#">this</a>.
The awesome answer and sketches are reproduced here for occasional review:</p>

<p><img class="center" src="/images/bash/LocalForwarding.png" width="600" height="500"></p>

<p><img class="center" src="/images/bash/RemoteForwarding.png" width="490" height="500"></p>

<pre><code class="plain Example 1">ssh -L 80:localhost:80 SUPERSERVER
</code></pre>

<p>In Example 1, you specify that a connection made to the local port 80 is to be forwarded to port 80 on SUPERSERVER.
That means if someone connects to your computer with a webbrowser, he gets the response of the webserver running on SUPERSERVER.
You, on your local machine, have no webserver running.</p>

<pre><code class="plain Example 2">ssh -R 80:localhost:80 tinyserver
</code></pre>

<p>In Example 2, you specify, that a connection made to the port 80 of tinyserver is to be forwarded to port 80 on your local machine.
That means if someone connects to the small and slow server with a webbrowser, he gets the response of the webserver running on your local machine.
The tinyserver, which has not enough diskspace for the big website, has no webserver running.
But people connecting to tinyserver think so.</p>

<p>Other things could be: The powerful machine has five webservers running on five different ports.
If a user connects to one of the five tinyservers at port 80 with his webbrowser, the request is redirected to the corresponding webserver running on the powerful machine.
That would be</p>

<pre><code class="plain Example 3 (before)">ssh -R 80:localhost:30180 tinyserver1
ssh -R 80:localhost:30280 tinyserver2
etc.
</code></pre>

<p>Or maybe your machine is only the connection between the powerful and the small servers.
Then it would be (for one of the tinyservers that play to have their own webservers):</p>

<pre><code class="plain Example 3 (after)">ssh -R 80:SUPERSERVER:30180 tinyserver1
ssh -R 80:SUPERSERVER:30280 tinyserver2
etc
</code></pre>
]]></content>
  </entry>
  
</feed>
