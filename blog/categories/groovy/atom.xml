<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Groovy | Personal Programming Notes]]></title>
  <link href="http://tdongsi.github.io/blog/categories/groovy/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/"/>
  <updated>2021-03-21T05:53:02-07:00</updated>
  <id>http://tdongsi.github.io/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Github REST API Cookbook]]></title>
    <link href="http://tdongsi.github.io/blog/2018/08/06/github-rest-api/"/>
    <updated>2018-08-06T21:37:20-07:00</updated>
    <id>http://tdongsi.github.io/blog/2018/08/06/github-rest-api</id>
    <content type="html"><![CDATA[<p>The blog post shows some useful snippets for interacting with Github API.
Jenkins pipelines regularly interacts with Github (public or Enterprise) API to perform some query/posting, for example, regarding the current pull request.
For that reason, some of the following snippets are either in Groovy or <code>curl</code> commands embedded in Groovy-based Jenkinsfile code with some Jenkinsfile DSLs.</p>

<!--more-->


<h3>Working with Pull Requests</h3>

<h4>Extracting Pull Request details</h4>

<pre><code class="groovy Get PR body text">import groovy.json.JsonSlurper

def getPrBody(String githubUsername, String githubToken, String repo, String id) {
  String GITHUB_API = 'https://git.enterprise.com/api/v3/repos'

  String url = "${GITHUB_API}/${githubUsername}/${repo}/pulls/${id}"
  println "Querying ${url}"
  def text = url.toURL().getText(requestProperties: ['Authorization': "token ${githubToken}"])
  def json = new JsonSlurper().parseText(text)
  def bodyText = json.body

  return bodyText
}
</code></pre>

<p>The equivalent <code>curl</code> command is as follows, with JSON processing is done in <code>jq</code>:</p>

<pre><code class="groovy Equivalent curl | jq command in Jenkisfile">sh """
curl -s -H "Authorization: token ${env.GITHUB_TOKEN}" ${GITHUB_API}/${org}/${repo}/pulls/${env.CHANGE_ID} | jq '.body' -r &gt; pr_body.txt
"""
</code></pre>

<h4>Posting comment on the Pull Request</h4>

<p>Reference: <a href="https://developer.github.com/v3/issues/comments/#create-a-comment">Create a comment</a>.</p>

<pre><code class="groovy Equivalent curl in Jenkinsfile">sh """
curl -s -X POST -H "Authorization: token ${env.GITHUB_TOKEN}" --data '{"body": "${comment}"}' ${GITHUB_API}/${org}/${repo}/issues/${env.CHANGE_ID}/comments
"""
</code></pre>

<h4>Merge Pull Request</h4>

<p>Based on <a href="http://www.cloudypoint.com/Tutorials/discussion/jenkins-solved-how-to-merge-a-successful-build-of-a-pull-request-using-a-jenkinsfile/">this article</a>.</p>

<pre><code class="groovy Merge pull request">stage ("Merge PR") {
    steps { 
        withCredentials([usernamePassword(credentialsId: 'credential-value', usernameVariable: 'ACCESS_TOKEN_USERNAME', passwordVariable: 'ACCESS_TOKEN_PASSWORD',)]) {
            def GITHUB = 'https://github.ibm.com/api/v3/repos'
            sh "curl -X PUT -d '{\"commit_title\": \"Merge pull request\"}' ${GITHUB}/org-name/repo-name/pulls/${env.CHANGE_ID}/merge?access_token=${env.ACCESS_TOKEN_PASSWORD}"
        }
    }
}
</code></pre>

<p>The Jenkins-provided environment variable <code>$CHANGE_ID</code>, in the case of a pull request, is the pull request number.</p>

<h3>Working with Branches</h3>

<h4>Getting email of branch maintainer</h4>

<p>At the end of a Jenkins build for a feature branch (NOT <code>develop</code>/<code>master</code>), you may want to email some developer of its status, as opposed to blasting a whole distribution list.
Note that in Git, there is no such metadata for branch creator, as discussed <a href="https://stackoverflow.com/questions/12055198/find-out-git-branch-creator/19135644">here</a>.
Instead, it makes more sense to notify the latest/active committer which is likely the owner of the branch.</p>

<!--
Furthermore, while most of the branches in Git has short lifetime, some branches such as `master` and `develop` can stay around for a long time.
That person may be not active or leave the project entirely.
-->


<pre><code class="groovy Get email of branch maintainer.">def getBranchCreator(String githubUsername, String githubToken, String repo, String branch) {
    String GITHUB_API = 'https://git.enterprise.com/api/v3/repos'

    String url = "${GITHUB_API}/${githubUsername}/${repo}/branches/${branch}"
    println "Querying ${url}"
    def text = url.toURL().getText(requestProperties: ['Authorization': "token ${githubToken}"])
    def json = new JsonSlurper().parseText(text)

    // Get last committer.
    def creator = json.commit.commit.committer.email
    // TRICKY: json.commit.commit.committer.email is not valid if someone commits from Github web interface.
    // In the case, committer name is 'GitHub Enterprise'.
    if (json.commit.commit.committer.name == 'GitHub Enterprise') {
    // Use author's email instead
    creator = json.commit.commit.author.email
    }
    // TRICKY: the following can return inconsistent data, including "null".
    // def author = json.author
    return creator
}

// Calling from Jenkinsfile
withCredentials([
    [$class: 'UsernamePasswordMultiBinding', credentialsId: 'my-credentials', 
        passwordVariable: 'GITHUB_PASSWORD', usernameVariable: 'GITHUB_USERNAME']
]) {
    if (env.BRANCH_NAME ==~ /PR-\d+/ ) {
        // If it is a PR build, use some distribution list
        email = 'someemail@enterprise.com'
    } else {
        // NOTE: Replace env.GITHUB_USERNAME with the correct Github org name.
        email = getBranchCreator(env.GITHUB_USERNAME, env.GITHUB_PASSWORD, 'my_repo', env.BRANCH_NAME)
    }
}  
</code></pre>

<h4>Deleting a branch</h4>

<p>Searching how to delete a branch in Github API&rsquo;s <a href="https://developer.github.com/v3/repos/branches/">Branches reference</a> does not return anything.
In fact, to delete a branch, we have to delete its HEAD reference as shown <a href="https://developer.github.com/v3/git/refs/#delete-a-reference">here</a>.</p>

<pre><code class="plain Deleting a branch">DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a
</code></pre>

<h3>More tips on Github API</h3>

<p>1) When processing data from Github API, note that any commit has an author and a committer, as shown below.</p>

<pre><code class="json Example commit data">        "commit": {
            "author": {
                "name": "Cuong Dong-Si",
                "email": "tdongsi@example.com",
                "date": "2017-08-17T05:33:46Z"
            },
            "committer": {
                "name": "Tue-Cuong Dong-Si",
                "email": "tdongsi@example.com",
                "date": "2017-08-17T05:33:46Z"
            },
            "message": "@JIRA-4214772@: Add function.",
            "tree": {
                "sha": "xxx",
                "url": "xxx"
            },
            "url": "xxx",
            "comment_count": 0
        },
</code></pre>

<p>While the two fields are usually the same in normal commits (with same associated email and timestamp), they have different meanings.
In summary, the author is the one who created the content, and the committer is the one who committed it.
The two fields can be different in some common Github workflows:</p>

<ul>
<li>Commit a change from Github web interface: The author is the logged-in user (e.g., tdongsi) but the &ldquo;committer&rdquo; field usually has the Github default name and email, e.g., &ldquo;Github Enterprise&rdquo; and &ldquo;<a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#x6e;&#x6f;&#x2d;&#114;&#x65;&#112;&#x6c;&#121;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;">&#110;&#x6f;&#45;&#114;&#101;&#x70;&#108;&#x79;&#x40;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a>&rdquo;.</li>
<li>Make and/or merge a pull request from Github: For example, Alice submitted a pull request which was accepted and then merged by Betty (the repository owner). In that case, the author is Alice and the committer is Betty.</li>
</ul>


<p>Due to that subtle difference in committer and author in different scenarios, one has to be careful when using data sent by Github API in a Jenkins pipeline.
For example, you want to send email to the repository owner (committer) at the end of a Pull Request build, but what if someone adds a commit via Github web interface (commiter email would be &ldquo;<a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x6e;&#111;&#x2d;&#114;&#101;&#x70;&#x6c;&#121;&#x40;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;">&#x6e;&#x6f;&#45;&#114;&#x65;&#112;&#x6c;&#x79;&#x40;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#111;&#x6d;</a>&rdquo; which is not helpful).</p>

<p>2) There is an API rate limit for the free public Github API (note &ldquo;X-RateLimit-Limit&rdquo; and &ldquo;X-RateLimit-Remaining&rdquo; in output below).</p>

<pre><code class="plain Github API limit">tdongsi-mac:dev tdongsi$ curl -i https://api.github.com/users/tdongsi
HTTP/1.1 200 OK
Date: Fri, 09 Jun 2017 16:16:49 GMT
Content-Type: application/json; charset=utf-8
Content-Length: 1236
Server: GitHub.com
Status: 200 OK
X-RateLimit-Limit: 60
X-RateLimit-Remaining: 55
X-RateLimit-Reset: 1497025098
Cache-Control: public, max-age=60, s-maxage=60
Vary: Accept
ETag: "4d7770cf5c2478bf64d23bc908494172"
Last-Modified: Thu, 01 Jun 2017 01:09:00 GMT
X-GitHub-Media-Type: github.v3; format=json
Access-Control-Expose-Headers: ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval
Access-Control-Allow-Origin: *
Content-Security-Policy: default-src 'none'
Strict-Transport-Security: max-age=31536000; includeSubdomains; preload
X-Content-Type-Options: nosniff
X-Frame-Options: deny
X-XSS-Protection: 1; mode=block
X-Runtime-rack: 0.030687
Vary: Accept-Encoding
X-Served-By: 62cdcc2d03a2f173f1c58590d1a90077
Vary: Accept-Encoding
X-GitHub-Request-Id: FADF:2CB6E:44F743B:56EDC6F:593AC9F1

...
</code></pre>

<p>You are likely to hit this rate limit quickly if you are polling the repos for updates.
Instead of polling from your CI (e.g., Jenkins) system, it is recommended to use <a href="https://developer.github.com/webhooks/creating/">Github webhooks</a>.</p>

<h3>Reference</h3>

<ul>
<li><a href="/blog/2015/08/04/curl-cookbook/">curl cookbook</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins Pipeline Unit Testing]]></title>
    <link href="http://tdongsi.github.io/blog/2018/06/07/jenkins-pipeline-unit-testing/"/>
    <updated>2018-06-07T22:33:46-07:00</updated>
    <id>http://tdongsi.github.io/blog/2018/06/07/jenkins-pipeline-unit-testing</id>
    <content type="html"><![CDATA[<p><a href="https://jenkins.io/doc/book/pipeline/shared-libraries/">Jenkins shared library</a> is a powerful way for sharing Groovy code between multiple Jenkins pipelines.
However, when many Jenkins pipelines, including mission-critical deployment pipelines, depend on such shared libraries, automated testing becomes necessary to prevent regressions whenever new changes are introduced into shared librariers.
Despite its drawbacks, the third-party <a href="https://github.com/jenkinsci/JenkinsPipelineUnit">Pipeline Unit Testing framework</a> satisfies some of automated testing needs.
It would allow you to do mock execution of pipeline steps and checking for expected behaviors before actually running in Jenkins.
However, documentation for this third-party framework is severely lacking (mentioned briefly <a href="https://jenkins.io/doc/book/pipeline/development/#unit-test">here</a>) and it is one of many reasons that unit testing for Jenkins shared libraries is usually an after-thought, instead of being integrated early.
In this blog post, we will see how to do unit testing for Jenkins shared library with the Pipeline Unit Testing framework.</p>

<!--more-->


<h3>Testing Jenkins shared library</h3>

<h4>Example Groovy file</h4>

<p>For this tutorial, we look at the following Groovy build wrapper as the example under test:</p>

<pre><code class="groovy buildWrapper.groovy">def call(Closure body) {
  def config = [:]

  if (body != null) {
    body.resolveStrategy = Closure.DELEGATE_FIRST
    body.delegate = config
    body()
  }

  def settings = config.settings ?: "settings.xml"

  node('java-agent') {
    stage('Checkout') {
      checkout scm
    }

    stage('Main') {
      // Test Python setup
      sh(script: 'python -c "import requests"', returnStatus: true)
      // Test Docker setup
      sh 'docker version'
    }

    stage('Post') {
      // Print info of standard tools
      sh 'ls -al'
      sh 'java -version'
      sh "mvn -s $settings -version"
      sh 'python -V'
    }
  }
}
</code></pre>

<p>After the shared library is set up properly, you can call the above Groovy build wrapper in Jenkinsfile as follows to use default parameters:</p>

<pre><code class="groovy Jenkinsfile for first use case ">buildWrapper {
}
</code></pre>

<p>or you can set the parameters in the wrapper&rsquo;s body as follows:</p>

<pre><code class="groovy Jenkinsfile for second use case">buildWrapper {
  settings = "dummy.xml"
}
</code></pre>

<p>In the next section, we will look into automated testing of both use cases using JenkinsPipelineUnit.</p>

<h4>Using JenkinsPipelineUnit</h4>

<p>To use JenkinsPipelineUnit, it is recommended to set up IntelliJ following <a href="/blog/2018/02/09/intellij-setup-for-jenkins-shared-library-development/">this tutorial</a>.</p>

<p>To test the above <code>buildWrapper.groovy</code> using the Jenkins Pipeline Unit, you can start with a unit test for the second use case as follows:</p>

<pre><code class="groovy">  /**
   * Represent the call:
   *     buildWrapper {
   *       settings = "dummy.xml"
   *     }
   *
   * @throws Exception
   */
  @Test
  public void configured() throws Exception {
    def script = loadScript('vars/buildWrapper.groovy')
    script.call({
      settings = "dummy.xml"
    })

    printCallStack()
  }
</code></pre>

<p>Unfortunately, when executing that unit test, it is very likely that you will get various errors that are not well-explained by JenkinsPipelineUnit documentation.</p>

<pre><code class="plain Stack trace">groovy.lang.MissingPropertyException: No such property: scm for class: demoWrapper

    at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:66)
    at org.codehaus.groovy.runtime.callsite.PogoGetPropertySite.getProperty(PogoGetPropertySite.java:51)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGroovyObjectGetProperty(AbstractCallSite.java:310)
    at demoWrapper$_call_closure1$_closure2.doCall(demoWrapper.groovy:19)
</code></pre>

<p>The short explanation is that the mock execution environment is not properly set up.
First, we need to call <code>setUp()</code> from the base class BaseRegressionTest of JenkinsPipelineUnit to set up the mock execution environment.
In addition, since most Groovy scripts will have this statement <code>checkout scm</code>, we need to <a href="https://github.com/jenkinsci/JenkinsPipelineUnit#mock-jenkins-variables">mock the Jenkins global variable</a> <code>scm</code>, which represents the SCM state (e.g., Git commit) associated with the current Jenkinsfile.
The most simple way to mock it is to set it to empty state as follows:</p>

<pre><code class="groovy Mocking Jenkins variable scm">binding.setVariable('scm', [:])
</code></pre>

<p>We can also set it to a more meaningful value such as a Git branch as follows:</p>

<pre><code class="groovy Mocking Jenkins variable scm">    binding.setVariable('scm', [
        $class: 'GitSCM',
        branches: [[name: 'master']],
        doGenerateSubmoduleConfigruations: false,
        extensions: [],
        submoduleCfg: [],
        userRemoteConfigs: [[url: "/var/git-repo"]]
    ])
</code></pre>

<p>However, an empty <code>scm</code> will usually suffice.
Besides Jenkins variables, we can also <a href="https://github.com/jenkinsci/JenkinsPipelineUnit#mock-jenkins-commands">register different Jenkins steps/commands</a> as follows:</p>

<pre><code class="groovy Mocking Jenkins step library">helper.registerAllowedMethod('library', [String.class], null)
</code></pre>

<p>After going through the setup steps above, you should have the following setup method like this:</p>

<pre><code class="groovy Minimum setup method">import com.lesfurets.jenkins.unit.BaseRegressionTest

class DemoTest extends BaseRegressionTest {

  @Override
  @Before
  public void setUp() throws Exception {
    super.setUp();
    binding.setVariable('scm', [:])
    helper.registerAllowedMethod('library', [String.class], null)
  }
...
}
</code></pre>

<p>Rerunning the above unit test will show the full stack of execution:</p>

<pre><code class="plain">   buildWrapper.call(groovy.lang.Closure)
      buildWrapper.node(java-agent, groovy.lang.Closure)
         buildWrapper.stage(Checkout, groovy.lang.Closure)
            buildWrapper.checkout({})
         buildWrapper.stage(Main, groovy.lang.Closure)
            buildWrapper.sh({script=python -c "import requests", returnStatus=true})
            buildWrapper.sh(docker version)
         buildWrapper.stage(Post, groovy.lang.Closure)
            buildWrapper.sh(ls -al)
            buildWrapper.sh(java -version)
            buildWrapper.sh(mvn -s dummy.xml -version)
            buildWrapper.sh(python -V)
</code></pre>

<p>For automated detection of regression, we need to save the expected call stack above into a file into a location known to JenkinsPipelineUnit.
You can specify the location of such call stacks by overriding the field <code>callStackPath</code> of BaseRegressionTest in <code>setUp</code> method.
The file name should follow the convention <code>${ClassName}_${subname}.txt</code> where <code>subname</code> is specified by <code>testNonRegression</code> method in each test case.
Then, you can update the above test case to perform regression check as follows:</p>

<pre><code class="groovy">  @Test
  public void configured() throws Exception {
    def script = loadScript('vars/demoWrapper.groovy')
    script.call({
      settings = "dummy.xml"
    })

    // printCallStack()
    testNonRegression("configured")
  }
</code></pre>

<p>In this example, the above call stack should be saved into <code>DemoTest_configured.txt</code> file at the location specified by <code>callStackPath</code>.
Similarly, you can also have another unit test for the other use case of <code>buildWrapper</code>.</p>

<pre><code class="groovy">  /**
   * Represent the call:
   * buildWrapper {
   * }
   *
   * @throws Exception
   */
  @Test
  public void default_value() throws Exception {
    def script = loadScript('vars/buildWrapper.groovy')
    script.call({})

    // printCallStack()
    testNonRegression("default")
  }
</code></pre>

<p>Any change in <code>buildWrapper.groovy</code> will be detected as test failures, as shown in the screen shot below.</p>

<p><img src="/images/idea/screen09.png" title="Difference" alt="Screeshot" /></p>

<p>In IntelliJ, we can click on <em>Click to see difference</em> link to compare the actual call stack versus the expected one that was saved in the text file.</p>

<p><img src="/images/idea/screen10.png" title="Compare" alt="Screeshot" /></p>

<p>This <a href="https://github.com/tdongsi/jenkins-steps-override/blob/master/test/vars/BuildWrapperTest.groovy">test class</a> shows a complete example, together with <a href="https://github.com/tdongsi/jenkins-steps-override/tree/master/test/vars/callstacks">files of expected call stacks</a>.</p>

<h3>Other usage</h3>

<p>You can also use PipelineUnitTests to test Jenkinsfile.
In most cases, testing Jenkinsfile will be similar to testing Groovy files in <code>vars</code> folder, as explained above, since they are quite similar.</p>

<pre><code class="groovy Example Jenkinsfile">node() {
  stage('Checkout') {
    checkout scm
    sh 'git clean -xdf'
  }

  stage('Build and test') {
    sh './gradlew build'
    junit 'build/test-results/test/*.xml'
  }
}
</code></pre>

<p>The process is very similar: you need to mock out some global variables and functions corresponding to Jenkins pipeline steps.
You will need to <code>printCallStack</code> to obtain the expected output and save it into some text file.
Then, you can use <code>testNonRegression</code> for automated verification of no-regression in Jenkinsfile.
<a href="https://github.com/tdongsi/jenkins-steps-override/blob/master/test/vars/JenkinsfileTest.groovy">This test class</a> shows an example of testing Jenkinsfile using PipelineUnitTests.</p>

<p>Note that, unlike Groovy files in <code>vars</code> folder, Jenkinsfiles are regularly updated and usually NOT depended/used by any other codes.
Therefore, automated tests for Jenkinsfile are not very common because of the cost/effort required.</p>

<h3>References</h3>

<ul>
<li><a href="https://github.com/jenkinsci/JenkinsPipelineUnit">JenkinsPipelineUnit</a></li>
<li><a href="https://www.youtube.com/watch?v=RmrpUtbVR7o">The talk at Jenkins World 17</a></li>
<li><a href="https://github.com/tdongsi/jenkins-steps-override">Example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IntelliJ Setup for Jenkins Development]]></title>
    <link href="http://tdongsi.github.io/blog/2018/02/09/intellij-setup-for-jenkins-shared-library-development/"/>
    <updated>2018-02-09T21:32:59-08:00</updated>
    <id>http://tdongsi.github.io/blog/2018/02/09/intellij-setup-for-jenkins-shared-library-development</id>
    <content type="html"><![CDATA[<p>This posts will show how to setup IntelliJ for development of Jenkins <a href="/blog/2017/12/30/groovy-hook-script-and-jenkins-configuration-as-code/">Groovy Init Scripts</a> and <a href="https://jenkins.io/doc/book/pipeline/shared-libraries/">shared libraries</a>, including auto-complete for <a href="https://jenkins.io/doc/pipeline/steps/">Jenkins pipeline steps</a>.
This is based on my original write-up in <a href="https://github.com/tdongsi/jenkins-config/blob/develop/docs/IDE.md">this project</a>.</p>

<!--more-->


<p>NOTE: this setup is NOT intended for Jenkins plugin or core development.</p>

<h3>Start a new Gradle project</h3>

<p>It is best to start a new project:</p>

<ol>
<li>Select <strong>File | New Project</strong></li>
<li>Select <strong>Gradle</strong></li>
<li>Select <strong>Java</strong> AND <strong>Groovy</strong>
<img src="/images/idea/screen01.png" title="Start" alt="Screeshot" /></li>
<li>Choose <strong>GroupId</strong> and <strong>ArtifactId</strong>
<img src="/images/idea/screen02.png" title="Project Name" alt="Screeshot" /></li>
<li>Enter path to Gradle. For Gradle on Mac installed via Homebrew, the Gradle home is like this:
<img src="/images/idea/screen03.png" title="Configure Gradle" alt="Screeshot" />
NOTE: For Gradle installed on a Mac via Homebrew, the path &ldquo;/usr/local/opt/gradle/libexec&rdquo; may be preferrable to &ldquo;/usr/local/Cellar/gradle/X.X/libexec&rdquo; since the former will stay the same after Gradle version upgrades.
In addition, if you work extensively with Grails/Gradle/Groovy, you may prefer installing via <a href="https://sdkman.io/install"><code>sdk</code> tool</a> instead of Homebrew.</li>
<li>Choose <strong>Project name</strong> and <strong>Project Location</strong>
<img src="/images/idea/screen04.png" title="Project location" alt="Screeshot" /></li>
<li>Finish
<img src="/images/idea/screen05.png" title="Finish" alt="Screeshot" /></li>
</ol>


<h3>Configure IDEA</h3>

<p>Set up for Jenkins Plugins files which are of types <strong>.hpi</strong> or <strong>.jpi</strong>.</p>

<ol>
<li>Select <strong>IntelliJ IDEA | Preferences | Editor | File Types</strong></li>
<li>Select <strong>Archive</strong></li>
<li>Select <strong>+</strong> at the bottom left corner</li>
<li>Add both <strong>.hpi</strong> and <strong>.jpi</strong></li>
<li>Select <strong>OK</strong></li>
</ol>


<p><img src="/images/idea/screen06.png" title="Configure plugin files" alt="Screeshot" /></p>

<p>Modify <strong>build.gradle</strong> to add the following lines.</p>

<pre><code class="groovy">    compile 'org.jenkins-ci.main:jenkins-core:2.23'

    // Jenkins plugins
    compile group: 'org.jenkins-ci.plugins', name: 'credentials', version: '2.1.13', ext: 'jar'
    compile group: 'org.jenkins-ci.plugins', name: 'matrix-auth', version: '1.6', ext: 'jar'
    compile group: 'org.jenkins-ci.plugins.workflow', name: 'workflow-cps', version: '2.39', ext: 'jar'

    // TRICKY: The lib folder contains all other plugins *JAR* files
    // if not found in Maven
    compile fileTree(dir: 'lib', include: ['*.jar'])
</code></pre>

<p>The above example will grab Jenkins core libraries, Matrix Authorization Plugin hpi, other plugin dependencies and javadocs for all imported libraries.
Having these libraries imported will enable code auto-completion, syntax checks, easy refactoring when working with Groovy scripts for Jenkins.
It will be a great productivity boost.</p>

<p>NOTE 1: The last line <code>compile fileTree</code> is the last resort for any Jenkins plugins that you cannot find the right group ID and artifact ID.
It is rare these days but such cases cannot be completely ruled out.</p>

<p>NOTE 2: The <code>ext: 'jar'</code> is VERY important to ensure that <code>jar</code> files, instead of <code>hpi</code>/<code>jpi</code> files, are being downloaded and understood by IntellJ.
Without that <code>ext</code> option specified, IntellJ won&rsquo;t find JAR files nested in <code>hpi</code>/<code>jpi</code> files which is the default binaries for Jenkins plugins.</p>

<p>The final <strong>build.gradle</strong> will look like <a href="https://github.com/tdongsi/jenkins-steps-override/blob/master/build.gradle">this</a>.
All of the above setup should suffice for working with <a href="http://tdongsi.github.io/blog/2017/12/30/groovy-hook-script-and-jenkins-configuration-as-code/">Groovy Init Scripts</a>.
For working with Jenkins Shared Pipeline Libraries, we should take one extra step shown as follows.</p>

<h3>Setup for Jenkins pipeline library</h3>

<p>All Groovy files in Jenkins shared library for Pipelines have to follow this directory structure:</p>

<pre><code class="text Directory structure of a Shared Library repository">(root)
+- src                     # Groovy source files
|   +- org
|       +- foo
|           +- Bar.groovy  # for org.foo.Bar class
+- vars
|   +- foo.groovy          # for global 'foo' variable
|   +- foo.txt             # help for 'foo' variable
+- resources               # resource files (external libraries only)
|   +- org
|       +- foo
|           +- bar.json    # static helper data for org.foo.Bar
</code></pre>

<p>Note that the Groovy code can be in both <a href="http://tdongsi.github.io/blog/2017/12/26/class-in-jenkins-shared-library/"><code>src</code></a>
and <a href="http://tdongsi.github.io/blog/2017/03/17/jenkins-pipeline-shared-libraries/"><code>vars</code></a> folders.
Therefore, you need to add the following lines in <code>build.gradle</code> to inform Gradle locations of Groovy source codes:</p>

<pre><code class="groovy">sourceSets {
    main {
        groovy {
            srcDirs = ['vars', 'src']
        }
    }

    test {
        groovy {
            srcDirs = ['test']
        }
    }
}
</code></pre>

<p>Optionally, for unit testing Jenkins shared library, we have to add the following dependencies into our <strong>build.gradle</strong> file.</p>

<pre><code class="groovy">    testCompile group: 'com.lesfurets', name: 'jenkins-pipeline-unit', version: '1.1'
    testCompile group: 'org.spockframework', name: 'spock-core', version: '1.1-groovy-2.4'
</code></pre>

<p>Please see <a href="/blog/2018/06/07/jenkins-pipeline-unit-testing/">this blog post</a> for more details on unit testing.
The final <strong>build.gradle</strong> will look like <a href="https://github.com/tdongsi/jenkins-steps-override/blob/master/build.gradle">this</a>.</p>

<h4>Auto-completion for Jenkins Pipeline</h4>

<p>IntelliJ can&rsquo;t auto-complete <a href="https://jenkins.io/doc/pipeline/steps/">Jenkins pipeline steps</a> such as <code>echo</code> or <code>sh</code> out of the box.
We have to make it aware of those Jenkins pipeline DSLs, via a generic process explained <a href="https://confluence.jetbrains.com/display/GRVY/Scripting+IDE+for+DSL+awareness">here</a>.
Fortunately, it is much easier than it looks and you don&rsquo;t have to actually write GroovyDSL script for tens of Jenkins pipeline steps.
Jenkins make it easy by auto-generating the GroovyDSL script and it is accessible via &ldquo;IntelliJ IDEA GDSL&rdquo; link, as shown in screenshot below.</p>

<p><img src="/images/idea/screen08.png" title="GroovyDSL" alt="Screeshot" /></p>

<p>The &ldquo;IntelliJ IDEA GDSL&rdquo; link can be found by accessing &ldquo;Pipeline Syntax&rdquo; section, which is visible in the left navigation menu of any Pipeline-based job (e.g., &ldquo;Admin&rdquo; job in the example above).
After clicking on the &ldquo;IntelliJ IDEA GDSL&rdquo; link, you will be able to download a plain text file with content starting like this:</p>

<pre><code class="groovy IntelliJ IDEA GDSL">//The global script scope
def ctx = context(scope: scriptScope())
contributor(ctx) {
method(name: 'build', type: 'Object', params: [job:'java.lang.String'], doc: 'Build a job')
method(name: 'build', type: 'Object', namedParams: [parameter(name: 'job', type: 'java.lang.String'), parameter(name: 'parameters', type: 'Map'), parameter(name: 'propagate', type: 'boolean'), parameter(name: 'quietPeriod', type: 'java.lang.Integer'), parameter(name: 'wait', type: 'boolean'), ], doc: 'Build a job')
method(name: 'echo', type: 'Object', params: [message:'java.lang.String'], doc: 'Print Message')
method(name: 'error', type: 'Object', params: [message:'java.lang.String'], doc: 'Error signal')
...
</code></pre>

<p>As you can see, it is a GroovyDSL file that describes the known pipeline steps such as <code>echo</code> and <code>error</code>.
Note that GDSL files can be different for different Jenkins instances, depending on Pipeline-supported plugins currently installed on individual Jenkins instance.
To make IntelliJ aware of the current Jenkins pipeline steps available on our Jenkins, we need to place that GDSL file into a location known to source folders.
As shown in the last section, anywhere in both <code>vars</code> and <code>src</code> folders are eligible as such although I personally prefer to put the GDSL file into <code>vars</code> folder (<a href="https://github.com/tdongsi/jenkins-steps-override/tree/master/vars">for example</a>).</p>

<p>After installing the GDSL file into a proper location, IntelliJ may complain with the following message <em>DSL descriptor file has been change and isnâ€™t currently executed</em> and you have to click <strong>Activate back</strong> to get the IntelliJ aware of the current DSLs.
After that, you can enjoy auto-completion as well as documentation of the Jenkine Pipeline DSLs.</p>

<h3>More information</h3>

<ul>
<li><a href="https://github.com/tdongsi/jenkins-steps-override">Example of final setup</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Groovy Hook Script and Jenkins Configuration as Code]]></title>
    <link href="http://tdongsi.github.io/blog/2017/12/30/groovy-hook-script-and-jenkins-configuration-as-code/"/>
    <updated>2017-12-30T21:02:48-08:00</updated>
    <id>http://tdongsi.github.io/blog/2017/12/30/groovy-hook-script-and-jenkins-configuration-as-code</id>
    <content type="html"><![CDATA[<p>This post discusses <a href="https://wiki.jenkins.io/display/JENKINS/Groovy+Hook+Script">Groovy Hook Scripts</a> and how to use them for full configuration-as-code in Jenkins with Docker, Pipeline.
This can help us to set up local environment for developing Jenkins Pipeline libraries and to evaluate various Jenkins features.</p>

<!--more-->


<h3>Groovy Hook Scripts</h3>

<p>These scripts are written in Groovy, and get executed inside the same JVM as Jenkins, allowing full access to the domain model of Jenkins.
For a given hook <code>HOOK</code>, the following locations are searched:</p>

<pre><code>WEB-INF/HOOK.groovy in jenkins.war
WEB-INF/HOOK.groovy.d/*.groovy in the lexical order in jenkins.war
$JENKINS_HOME/HOOK.groovy
$JENKINS_HOME/HOOK.groovy.d/*.groovy in the lexical order
</code></pre>

<p>The <code>init</code> is the most commonly used hook (i.e., <code>HOOK=init</code>).
The following sections show how some of the most common tasks and configurations in Jenkins can be achieved by using such Groovy scripts.
For example, in <a href="https://github.com/tdongsi/jenkins-config">this project</a>, many of such scripts are added into a Dockerized Jenkins master and executed when
starting a container to replicate configurations of the Jenkins instance in production.
It will give us ability to quickly spin up local Jenkins instances for development or troubleshooting issues in production Jenkins.</p>

<p>On a side note, IntelliJ IDEA is probably the best development tool for working with these Groovy Scripts.
Check out <a href="https://github.com/tdongsi/jenkins-config/blob/develop/docs/IDE.md">these instructions on how to set it up in IntelliJ</a>.
<em>UPDATED ON 2018/09/29</em>: More on IntelliJ setup is discussed in <a href="/blog/2018/02/09/intellij-setup-for-jenkins-shared-library-development/">this blog post</a>.</p>

<h3>Authorization</h3>

<p>This section shows how to enable different authorization strategies in Groovy code.</p>

<pre><code class="groovy "Logged-in users can do anything"">import jenkins.model.*
def instance = Jenkins.getInstance()

import hudson.security.*
def realm = new HudsonPrivateSecurityRealm(false)
instance.setSecurityRealm(realm)

def strategy = new hudson.security.FullControlOnceLoggedInAuthorizationStrategy()
strategy.setAllowAnonymousRead(false)
instance.setAuthorizationStrategy(strategy)

instance.save()
</code></pre>

<p>Matrix-based authorization: Gives all authenticated users admin access:</p>

<pre><code class="groovy Matrix-based authorization">import jenkins.model.*
def instance = Jenkins.getInstance()

import hudson.security.*
def realm = new HudsonPrivateSecurityRealm(false)
instance.setSecurityRealm(realm)

def strategy = new hudson.security.GlobalMatrixAuthorizationStrategy()
strategy.add(Jenkins.ADMINISTER, 'authenticated')
instance.setAuthorizationStrategy(strategy)

instance.save()
</code></pre>

<p>For importing GlobalMatrixAuthorizationStrategy class, make sure that <a href="https://wiki.jenkins.io/display/JENKINS/Matrix+Authorization+Strategy+Plugin"><code>matrix-auth</code> plugin</a> is installed.
For full list of standard permissions in the matrix, see <a href="https://gist.github.com/jnbnyc/c6213d3d12c8f848a385">this code snippet</a>.
Note that the matrix can be different if different plugins are installed.
For example, the &ldquo;Replay&rdquo; permission for Runs is not simply <code>hudson.model.Run.REPLAY</code> since there is no such static constant.
Such permission is only available after <a href="https://github.com/jenkinsci/workflow-cps-plugin">Workflow CPS plugin</a> is installed.
Therefore, we can only set &ldquo;Replay&rdquo; permission for Runs with the following:</p>

<pre><code class="groovy">strategy.add(org.jenkinsci.plugins.workflow.cps.replay.ReplayAction.REPLAY,USER)
</code></pre>

<p><strong>References</strong></p>

<ul>
<li><a href="https://gist.github.com/jnbnyc/c6213d3d12c8f848a385">Matrix-based Authorizaiton</a></li>
<li><a href="https://github.com/oleg-nenashev/demo-jenkins-config-as-code">Jenkins config as code</a></li>
</ul>


<h3>Basic Jenkins security</h3>

<p>In addition to enable authorization strategy, we should also set some basic configurations for hardening Jenkins.
Those includes various options that you see in Jenkins UI when going to Manage Jenkins > Configure Global Security.</p>

<ul>
<li><a href="https://support.cloudbees.com/hc/en-us/articles/234709648-Disable-Jenkins-CLI">Disable Jenkins CLI</a></li>
<li>Limit Jenkins agent protocols.</li>
<li>&ldquo;Enable Slave -> Master Access Control&rdquo;</li>
<li>&ldquo;Prevent Cross Site Request Forgery exploits&rdquo;</li>
</ul>


<pre><code class="groovy Basic Jenkins security">import hudson.security.csrf.DefaultCrumbIssuer
import jenkins.model.Jenkins
import jenkins.model.JenkinsLocationConfiguration
import jenkins.security.s2m.AdminWhitelistRule
import org.kohsuke.stapler.StaplerProxy
import hudson.tasks.Mailer

println("--- Configuring Remoting (JNLP4 only, no Remoting CLI)")
Jenkins.instance.getDescriptor("jenkins.CLI").get().setEnabled(false)
Jenkins.instance.agentProtocols = new HashSet&lt;String&gt;(["JNLP4-connect"])

println("--- Enable Slave -&gt; Master Access Control")
Jenkins.instance.getExtensionList(StaplerProxy.class)
    .get(AdminWhitelistRule.class)
    .masterKillSwitch = false

println("--- Checking the CSRF protection")
if (Jenkins.instance.crumbIssuer == null) {
    println "CSRF protection is disabled, Enabling the default Crumb Issuer"
    Jenkins.instance.crumbIssuer = new DefaultCrumbIssuer(true)
}

println("--- Configuring Quiet Period")
// We do not wait for anything
Jenkins.instance.quietPeriod = 0
Jenkins.instance.save()

println("--- Configuring Email global settings")
JenkinsLocationConfiguration.get().adminAddress = "admin@non.existent.email"
Mailer.descriptor().defaultSuffix = "@non.existent.email"
</code></pre>

<p>Some are not working for versions before 2.46, according to <a href="https://support.cloudbees.com/hc/en-us/articles/234709648-Disable-Jenkins-CLI">this</a>.
For disabling Jenkins CLI, you can simply add the java argument <code>-Djenkins.CLI.disabled=true</code> on Jenkins startup.</p>

<p><strong>References</strong></p>

<ul>
<li><a href="https://support.cloudbees.com/hc/en-us/articles/234709648-Disable-Jenkins-CLI">Disable Jenkins CLI: different versions</a></li>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Slave+To+Master+Access+Control">Slave to Master Access Control</a></li>
</ul>


<h3>Create Jobs and Items</h3>

<pre><code class="groovy Create "Pipeline script from SCM" job">import hudson.plugins.git.*;

def scm = new GitSCM("git@github.com:dermeister0/Tests.git")
scm.branches = [new BranchSpec("*/develop")];

def flowDefinition = new org.jenkinsci.plugins.workflow.cps.CpsScmFlowDefinition(scm, "Jenkinsfile")

def parent = Jenkins.instance
def job = new org.jenkinsci.plugins.workflow.job.WorkflowJob(parent, "New Job")
job.definition = flowDefinition
</code></pre>

<ul>
<li><a href="https://stackoverflow.com/questions/16963309/how-create-and-configure-a-new-jenkins-job-using-groovy">Stackoverflow thread</a></li>
<li><a href="https://github.com/linagora/james-jenkins/blob/master/create-dsl-job.groovy">More example</a></li>
</ul>


<h3>Create different kinds of Credentials</h3>

<p>Adding Credentials to a new, local Jenkins for development or troubleshooting can be a daunting task.
However, with the following scripts and the right setup (NEVER commit your secrets into VCS), developers can automate adding the required Credentials into the new Jenkins.</p>

<pre><code class="groovy Preamble">import com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl
import org.jenkinsci.plugins.plaincredentials.impl.StringCredentialsImpl
import org.jenkinsci.plugins.plaincredentials.impl.FileCredentialsImpl
import com.cloudbees.plugins.credentials.domains.Domain
import com.cloudbees.plugins.credentials.CredentialsScope
import jenkins.model.Jenkins
import hudson.util.Secret
import com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey
import com.cloudbees.plugins.credentials.impl.CertificateCredentialsImpl
import com.cloudbees.plugins.credentials.SecretBytes

def domain = Domain.global()
def store = Jenkins.instance.getExtensionList('com.cloudbees.plugins.credentials.SystemCredentialsProvider')[0].getStore()
</code></pre>

<pre><code class="groovy "Username with Password" type">def githubAccount = new UsernamePasswordCredentialsImpl(
        CredentialsScope.GLOBAL, "test-github", "Test Github Account",
        "testuser",
        "testpassword"
)
store.addCredentials(domain, githubAccount)
</code></pre>

<pre><code class="groovy "Secret text" type">def secretString = new StringCredentialsImpl(
        CredentialsScope.GLOBAL, "test-secret-string", "Test Secret String",
        Secret.fromString("testpassword")
)
store.addCredentials(domain, secretString)
</code></pre>

<pre><code class="groovy "Secret file" type">// Text file
def secret = '''Hi,
This is the content of the file.
'''

def secretBytes = SecretBytes.fromBytes(secret.getBytes())
def secretFile = new FileCredentialsImpl(
  CredentialsScope.GLOBAL, 
  'text-secret-file', 
  'description', 
  'file.txt', 
  secretBytes)
store.addCredentials(domain, secretFile)

// Binary file
Path fileLocation = Paths.get("/path/to/some/file.tar");
def secretBytes = SecretBytes.fromBytes(Files.readAllBytes(fileLocation))
def secretFile = new FileCredentialsImpl(
  CredentialsScope.GLOBAL, 
  'binary-secret-file', 
  'description', 
  'file.tar', 
  secretBytes)
store.addCredentials(domain, secretFile)
</code></pre>

<pre><code class="groovy "SSH Username with private key" type">String keyfile = "/var/jenkins_home/.ssh/id_rsa"
def privateKey = new BasicSSHUserPrivateKey(
        CredentialsScope.GLOBAL,
        "jenkins_ssh_key",
        "git",
        new BasicSSHUserPrivateKey.FileOnMasterPrivateKeySource(keyfile),
        "",
        ""
)
store.addCredentials(domain, privateKey)
</code></pre>

<pre><code class="groovy "Certificate" type">String minikubeKeyfile = "/var/jenkins_home/secret_data/minikube.pfx"
def minikubeCreds = new CertificateCredentialsImpl(
        CredentialsScope.GLOBAL,
        "minikube",
        "Minikube client certificate",
        "secret",
        new CertificateCredentialsImpl.FileOnMasterKeyStoreSource(minikubeKeyfile))
store.addCredentials(domain, minikubeCreds)
</code></pre>

<ul>
<li><a href="https://support.cloudbees.com/hc/en-us/articles/217708168-create-credentials-from-groovy">CloudBees tutorial</a></li>
<li><a href="https://github.com/tdongsi/jenkins-config/blob/develop/init_scripts/src/main/groovy/scripts/Credentials.groovy">Examples</a></li>
</ul>


<h3>Notifications</h3>

<pre><code class="groovy Configure Slack">import jenkins.model.*
def instance = Jenkins.getInstance()

// configure slack
def slack = Jenkins.instance.getExtensionList(
  jenkins.plugins.slack.SlackNotifier.DescriptorImpl.class
)[0]
def params = [
  slackTeamDomain: "domain",
  slackToken: "token",
  slackRoom: "",
  slackBuildServerUrl: "$JENKINS_URL",
  slackSendAs: ""
]
def req = [
  getParameter: { name -&gt; params[name] }
] as org.kohsuke.stapler.StaplerRequest
slack.configure(req, null)
slack.save()
</code></pre>

<pre><code class="groovy Global email settings">import jenkins.model.*
def instance = Jenkins.getInstance()

// set email
def location_config = JenkinsLocationConfiguration.get()
location_config.setAdminAddress("jenkins@skynet.net")
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[`src` Folder in Jenkins Shared Library]]></title>
    <link href="http://tdongsi.github.io/blog/2017/12/26/class-in-jenkins-shared-library/"/>
    <updated>2017-12-26T11:18:09-08:00</updated>
    <id>http://tdongsi.github.io/blog/2017/12/26/class-in-jenkins-shared-library</id>
    <content type="html"><![CDATA[<p>This post reviews best practices when we implement Groovy classes and/or static Groovy methods, in <code>src</code> folder as opposed to <code>vars</code> folder, for Jenkins Shared Library.</p>

<!--more-->


<h3>Examples of shared libraries in <code>src</code> folder</h3>

<p>All Groovy files in Jenkins shared library for pipelines have to follow this directory structure:</p>

<pre><code class="plain Directory structure of a Shared Library repository">(root)
+- src                     # Groovy source files
|   +- org
|       +- foo
|           +- Bar.groovy  # for org.foo.Bar class
+- vars
|   +- foo.groovy          # for global 'foo' variable
|   +- foo.txt             # help for 'foo' variable
+- resources               # resource files (external libraries only)
|   +- org
|       +- foo
|           +- bar.json    # static helper data for org.foo.Bar
</code></pre>

<p><code>src</code> folder is intended to set up with <code>groovy</code> files in the standard directory structure, such as &ldquo;src/org/foo/bar.groovy&rdquo;.
It will be added to the class path when the Jenkins pipelines are executed.</p>

<p>Any custom function in a Jenkins shared library has to eventually use basic Pipeline steps such as <code>sh</code> or <code>git</code>, made available through various Jenkins plugins.
However, Groovy classes in shared Jenkins library cannot simply call those basic steps directly.
There are a few approaches on how to access those Pipeline steps indirectly.</p>

<h3>Method 1: Methods in implicit class</h3>

<p>Groovy scripts in <code>src</code> folder can implement methods that invoke Pipeline steps, like this:</p>

<pre><code class="groovy Example 1">// src/org/demo/buildUtils.groovy
package org.demo

def checkOutFrom(repo) {
  git url: "git@github.com:jenkinsci/${repo}"
}
</code></pre>

<p>The method is stored implicitly in library and can then be invoked from a Scripted Pipeline like this:</p>

<pre><code class="groovy Example 1 (continued)">def myUtils = new org.demo.buildUtils()
myUtils.checkOutFrom(repo)
</code></pre>

<p>However, the requirement of this approach is that those methods defined in <code>buildUtils.groovy</code> cannot be enclosed in any class.
The &ldquo;implicit class&rdquo; mentioned in this approach refers to the fact that any Groovy script, such as <code>buildUtils.groovy</code>, has an implicit class (e.g., <code>org.demo.buildUtils</code>) that contains all the defined functions in it.
This approach has limitations; for example, it prevents the declaration of a superclass.</p>

<h3>Method 2: Explicit objects</h3>

<p>In the following example, we create an enclosing class that would facilitate things like defining a superclass.
In that case, to access standard DSL steps such as <code>sh</code> or <code>git</code>, we can explicitly pass special global variables <code>env</code> and <code>steps</code> into a constructor or a method of the class.
Global object <code>env</code> contains all current environment variables while <code>steps</code> contains all standard pipeline steps.
Note that the class must also implement Serializable interface to support saving the state if the pipeline is stopped or resumed.</p>

<pre><code class="groovy Example 2">package org.demo
class Utilities implements Serializable {
  def env
  def steps
  Utilities(env, steps) {
    this.env = env
    this.steps = steps
  }

  def mvn(args) {
    steps.sh "${steps.tool 'Maven'}/bin/mvn -o ${args}"
  }
}
</code></pre>

<pre><code class="groovy Example 2 (continued)">@Library('utils') 
import org.foo.Utilities

def utils = new Utilities(env, steps)
node {
  utils.mvn 'clean package'
}
</code></pre>

<h3>Method 3: Static methods in explicit class</h3>

<p>In the final example, we can also use static method and pass in the <code>script</code> object, which already has access to everything, including environment variables <code>script.env</code> and Pipeline steps such as <code>script.sh</code>.</p>

<pre><code class="groovy Example 3">package org.demo
class Utilities {
  static def mvn(script, args) {
    script.sh "${script.tool 'Maven'}/bin/mvn -s ${script.env.HOME}/jenkins.xml -o ${args}"
  }
}
</code></pre>

<p>The above example shows the script being passed in to one static method, invoked from a Scripted Pipeline as follows (note <code>import static</code>):</p>

<pre><code class="groovy Example 3 (continued)">@Library('utils') 
import static org.demo.Utilities.*
node {
  mvn this, 'clean package'
}
</code></pre>

<h3>Recommended practices</h3>

<p>All three approaches shown in three examples above are valid in Scripted Jenkinsfile.
However, per <a href="https://youtu.be/M8U9RyL756U?list=PLvBBnHmZuNQLqgKDFmGnUClw68qsQ9Hq5&amp;t=2310">recommended</a> by <a href="https://www.slideshare.net/BrentLaster/2017-jenkins-world/36">CloudBees Inc.</a>, <code>src</code> folder is best for utility classes that contains a bunch of static Groovy methods.
It is easier to use global variables in the <code>vars</code> directory instead of classes in the <code>src</code> directory, especially when you need to support <strong>declarative</strong> pipelines in your team.
The reason is that in declarative pipelines, the custom functions in Jenkins shared libraries must be callable in declarative syntax, e.g., &ldquo;myCustomFunction var1, var2&rdquo; format.
As you can see in the examples above, only in Method 3 (Static methods in explicit class), where custom functions are defined as static methods, the invocation of custom function is compatible with declarative pipeline syntax.</p>

<p>When using <code>src</code> area&rsquo;s Groovy codes with <code>library</code> step, you should use a temporary variable to reduce its verbosity, as follows:</p>

<pre><code class="groovy Reduce verbosity">def mvn = library('utils').org.demo.Utilities.mvn
mvn this, 'clean package'
// or 
// mvn self, 'clean package'
</code></pre>

<h3>Reference</h3>

<ul>
<li><a href="https://youtu.be/M8U9RyL756U?list=PLvBBnHmZuNQLqgKDFmGnUClw68qsQ9Hq5&amp;t=1576">Great Talk at Jenkins World 2017</a></li>
<li><a href="https://jenkins.io/doc/book/pipeline/shared-libraries/">Accessing Steps section in Jenkins Doc</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
