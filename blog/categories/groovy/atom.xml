<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Groovy | Personal Programming Notes]]></title>
  <link href="http://tdongsi.github.io/blog/categories/groovy/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/"/>
  <updated>2017-07-10T10:35:49-07:00</updated>
  <id>http://tdongsi.github.io/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Troubleshooting Groovy Code in Jenkinsfile]]></title>
    <link href="http://tdongsi.github.io/blog/2017/06/16/troubleshooting-groovy-scripts-in-jenkinsfile/"/>
    <updated>2017-06-16T23:52:44-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/06/16/troubleshooting-groovy-scripts-in-jenkinsfile</id>
    <content type="html"><![CDATA[<p>In this post, we look into some troubleshooting tips when <a href="/blog/2017/04/18/groovy-code-in-jenkins-pipeline/">using independent Groovy scripts in Jenkins pipeline</a> and how to work around those.</p>

<!--more-->


<h3>Cannot load a Groovy script in Declarative Pipeline</h3>

<p><strong>Problem</strong>: Loading Groovy methods from a file with <code>load</code> step does not work inside Declarative Pipeline step, as reported in <a href="https://issues.jenkins-ci.org/browse/JENKINS-43455">this issue</a>.</p>

<p><strong>Workaround</strong>: There are a few work-arounds. The most straight-forward one is to use <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline"><code>script</code> step</a>.</p>

<pre><code class="groovy Loading Groovy script">    steps {
        checkout scm
        withCredentials([
            [$class: 'StringBinding', credentialsId: 'nexusUserName', variable: 'nexusUserName'],
            [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'nexusPassword']
        ]) {
            script {
                myScript = load 'jenkins/xml.groovy'
                String myFile = myScript.transformXml(settingsFile, env.nexusUserName, env.nexusPassword)
                sh "mvn -B -s ${myFile} clean compile"

                sh "rm ${myFile}"
            }
        }
    }
</code></pre>

<p> You can also define Groovy methods from inside the Jenkinsfile.</p>

<pre><code class="groovy Example Jenkinsfile">import groovy.xml.StreamingMarkupBuilder
import groovy.xml.XmlUtil

@NonCPS
def xmlTransform(txt, username, password) {

    def xmlRoot = new XmlSlurper(false, false).parseText(txt)
    echo 'Start tranforming XML'
    xmlRoot.servers.server.each { node -&gt;
       node.username = username
       node.password = password
    }

    // TRICKY: FileWriter does NOT work
    def outWriter = new StringWriter()
    XmlUtil.serialize( xmlRoot, outWriter )
    return outWriter.toString()
}

...

   steps {
        checkout scm
        withCredentials([
            [$class: 'StringBinding', credentialsId: 'nexusUserName', variable: 'nexusUserName'],
            [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'nexusPassword']
        ]) {
            script {
                myScript = load 'jenkins/xml.groovy'
                String myFile = xmlTransform(settingsFile, env.nexusUserName, env.nexusPassword)
                sh "mvn -B -s ${myFile} clean compile"

                sh "rm ${myFile}"
            }
        }
    }
</code></pre>

<p>For Declarative Pipeline, to reuse the code from a Groovy script, you must use Shared Libraries.
Shared Libraries are not specific to Declarative; they were released some time ago and were seen in Scripted Pipeline.
<a href="/blog/2017/03/17/jenkins-pipeline-shared-libraries/">This blog post</a> discusses an older mechanism for Shared Library.
For the newer mechanism of importing library, please check out <a href="https://jenkins.io/blog/2017/02/15/declarative-notifications/">this blog post</a>.
Due to Declarative Pipelineâ€™s lack of support for defining methods, Shared Libraries definitely take on a vital role for code-reuse in Jenkinsfile.</p>

<h3><code>File</code> reading and writing not supported</h3>

<p>Java/Grooy reading and writing using &ldquo;java.io.File&rdquo; class is not directly supported.</p>

<pre><code class="groovy Using File class does NOT work">def myFile = new File('/home/data/myfile.xml')
</code></pre>

<p>In fact, using that class in Jenkinsfile must go through &ldquo;In-Process Script Approval&rdquo; with this warning.</p>

<p><blockquote><p>new java.io.File java.lang.String Approving this signature may introduce a security vulnerability! You are advised to deny it.</p></blockquote></p>

<p>Even then, &ldquo;java.io.File&rdquo; will refer to <strong>files on the master</strong> (where Jenkins is running), not the current workspace on Jenkins slave (or slave container).
As a result, it will report the following error even though the file is present in filesystem (<a href="https://stackoverflow.com/questions/41739468/groovy-reports-that-a-file-doesnt-exists-when-it-really-is-present-in-the-syste">relevant Stackoverflow</a>) on slave:</p>

<pre><code class="plain">java.io.FileNotFoundException: /home/data/myfile.xml (No such file or directory)
    at java.io.FileInputStream.open0(Native Method)
</code></pre>

<p>That also means related class such as FileWriter will NOT work as expected.
It reports no error during execution but you will find no file since those files are created on Jenkins master.</p>

<p><strong>Workaround</strong>:</p>

<ul>
<li>For file reading, use <a href="https://jenkins.io/doc/pipeline/steps/workflow-basic-steps/#readfile-read-file-from-workspace"><code>readFile</code> step</a>.</li>
<li>For file writing, use <code>writeFile</code> step. However, Pipeline steps (such as <code>writeFile</code>) are NOT allowed in <code>@NonCPS</code> methods. For more complex file writing, you might want to export the file content as String and use the following code snippet:</li>
</ul>


<pre><code class="groovy Shell command">    String xmlFile = ...

    // TRICKY: FileWriter does NOT work in xmlTransform
    def mCommand = "cat &gt;${settingsFile} &lt;&lt;EOF"
    mCommand += "\n${xmlFile}\nEOF"
    sh mCommand
</code></pre>

<p>In the code snippet above, we construct a <a href="https://en.wikipedia.org/wiki/Here_document#Unix_shells"><em>here document</em>-formatted</a> command for writing multi-line string in <code>mCommand</code> before passing to <code>sh</code> step for executing.</p>

<pre><code class="plain heredoc example to explain mCommand">$ cat &gt;output.txt &lt;&lt;EOF
SELECT foo, bar FROM db
WHERE foo='baz'
More line from xmlFile
EOF

$ cat output.txt
SELECT foo, bar FROM db
WHERE foo='baz'
More line from xmlFile
</code></pre>

<h3>Serialization errors</h3>

<p>You often encounter this type of errors when using non-serialiable classes from Groovy/Java libraries.</p>

<pre><code class="plain Error in Jenkins log">java.io.NotSerializableException: org.codehaus.groovy.control.ErrorCollector
    at org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:860)
</code></pre>

<pre><code class="plain Related error in Jenkins log">java.lang.UnsupportedOperationException: Calling public static java.lang.Iterable 
org.codehaus.groovy.runtime.DefaultGroovyMethods.each(java.lang.Iterable,groovy.lang.Closure) on a
CPS-transformed closure is not yet supported (JENKINS-26481); 
encapsulate in a @NonCPS method, or use Java-style loops
    at org.jenkinsci.plugins.workflow.cps.GroovyClassLoaderWhitelist.checkJenkins26481
    (GroovyClassLoaderWhitelist.java:90)
</code></pre>

<p>There is also some known <a href="https://issues.jenkins-ci.org/browse/JENKINS-35140">issue about JsonSlurper</a>.
These problems come from the fact that variables in Jenkins pipelines must be serializable.
Since pipeline must survive a Jenkins restart, the state of the running program is periodically saved to disk for possible resume later.
Any &ldquo;live&rdquo; objects such as a network connection is not serializble.</p>

<p><strong>Workaround</strong>:
Explicitly discard non-serializable objects or use <a href="https://support.cloudbees.com/hc/en-us/articles/230612967-Pipeline-The-pipeline-even-if-successful-ends-with-java-io-NotSerializableException">@NonCPS</a> methods.</p>

<p>Quoted from <a href="https://github.com/jenkinsci/workflow-cps-plugin/blob/master/README.md">here</a>: <code>@NonCPS</code> methods may safely use non-<code>Serializable</code> objects as local variables, though they should NOT accept nonserializable parameters or return or store nonserializable values.
You may NOT call regular (CPS-transformed) methods, or Pipeline steps, from a <code>@NonCPS</code> method, so they are best used for performing some calculations before passing a summary back to the main script.</p>

<h3>References</h3>

<ul>
<li><a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline">Declarative syntax</a></li>
<li><a href="https://jenkins.io/blog/2017/02/15/declarative-notifications/">Shared Libraries for Declarative Pipeline</a></li>
<li>Here document

<ul>
<li><a href="https://en.wikipedia.org/wiki/Here_document#Unix_shells">Theory</a></li>
<li><a href="https://stackoverflow.com/questions/2500436/how-does-cat-eof-work-in-bash">Common usage from Stackoverflow</a></li>
<li><a href="http://www.guguncube.com/2140/unix-set-a-multi-line-text-to-a-string-variable-or-file-in-bash">Heredoc with and without variable expansion</a></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven and Gradle Builds in Jenkinsfile]]></title>
    <link href="http://tdongsi.github.io/blog/2017/05/20/gradle-settings-in-jenkinsfile/"/>
    <updated>2017-05-20T23:27:08-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/05/20/gradle-settings-in-jenkinsfile</id>
    <content type="html"><![CDATA[<p>In this post, we will look into how to securely authenticate with Nexus for Maven and Gradle builds in Jenkins pipelines.
Nexus username and password should NOT be stored in plain text on Jenkins slaves or Docker images.
Instead, those credentials should be passed into Jenkins pipeline using <code>withCredentials</code> step.</p>

<!--more-->


<h3>Maven</h3>

<p>Maven builds in corporates usually use private repositories on Nexus, instead of public ones in Maven Central Repository.
To do that, we usually configure Maven to check Nexus instead of the default, built-in connection to Maven Central.
These configurations is stored in <em>~/.m2/settings.xml</em> file.</p>

<p>For authentication with Nexus and for deployment, we must <a href="https://books.sonatype.com/nexus-book/reference/_adding_credentials_to_your_maven_settings.html">provide credentials accordingly</a>.
We usually add the credentials into our Maven Settings in <em>settings.xml</em> file.</p>

<pre><code class="xml Example Credentials in settings.xml">&lt;settings&gt;
  &lt;servers&gt;
    &lt;server&gt;
      &lt;id&gt;nexus&lt;/id&gt;
      &lt;username&gt;deployment&lt;/username&gt;
      &lt;password&gt;deployment123&lt;/password&gt;
    &lt;/server&gt;
  &lt;/servers&gt;
&lt;/settings&gt;
</code></pre>

<p>However, for automated build and deployment in Jenkins pipelines, it is not safe to store credentials in plain text files.
Instead, one should store Nexus credentials as <a href="https://wiki.jenkins-ci.org/display/JENKINS/Credentials+Plugin">secrets in Jenkins</a> and pass them into Jenkinsfile using their IDs (<code>credentialsId</code>).
See <a href="https://support.cloudbees.com/hc/en-us/articles/203802500-Injecting-Secrets-into-Jenkins-Build-Jobs">this article</a> for the full picture of related plugins used for storing and passing secrets in Jenkins.</p>

<pre><code class="groovy Nexus authentication for Maven in Jenkinsfile.">  withCredentials([
    [$class: 'StringBinding', credentialsId: 'nexusUsername', variable: 'nexusUsername'],
    [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'nexusPassword']
  ]) {
    withEnv([
      'nexusPublic=https://nexus.example.com/nexus/content/groups/public/'
    ]) {
      def xmlTemplate = readFile templateFile
      String xmlFile = transformXml(xmlTemplate, env.nexusUsername, env.nexusPassword)

      String tempFile = 'temp.xml'
      writeFile file: tempFile, text: xmlFile

      sh "mvn -B clean build -s ${tempFile}"
    }
  }
</code></pre>

<p>The <a href="https://jenkins.io/doc/pipeline/steps/credentials-binding/">step <code>withCredentials</code></a> will not only provide a secure way of injecting secrets (e.g., Nexus credentials) into Jenkins pipeline, but also scrub away such sensitive information if we happen to print them out in log files.
<code>transformXml</code> is my Groovy function that generates the <code>settings.xml</code> from the redacted Maven settings.xml template (no credentials) and the provided Nexus credentials.</p>

<h4>Maven 3.0</h4>

<p>Since <strong>Maven 3.0</strong>, the above problem is made much easier since environment variables can be referred inside <code>settings.xml</code> file by using special expression <code>${env.VAR_NAME}</code>, based on <a href="https://maven.apache.org/settings.html">this doc</a>.
Nexus authentication for Maven 3.0 in Jenkins pipeline can be done as follows:</p>

<pre><code class="xml settings.xml in Maven 3.0">&lt;settings&gt;
  &lt;servers&gt;
    &lt;server&gt;
      &lt;id&gt;nexus&lt;/id&gt;
      &lt;username&gt;${env.MVN_SETTINGS_nexusUsername}&lt;/username&gt;
      &lt;password&gt;${env.MVN_SETTINGS_nexusPassword}&lt;/password&gt;
    &lt;/server&gt;
  &lt;/servers&gt;
&lt;/settings&gt;
</code></pre>

<pre><code class="groovy Passing Nexus credentials for Maven 3.0 in Jenkinsfile">  withCredentials([
    [$class: 'StringBinding', credentialsId: 'nexusUsername', variable: 'MVN_SETTINGS_nexusUsername'],
    [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'MVN_SETTINGS_nexusPassword']
  ]) {
    withEnv([
      'nexusPublic=https://nexus.example.com/nexus/content/groups/public/'
    ]) {
      sh 'mvn -s settings.xml clean build'
    }
  }
</code></pre>

<p>However, note that it is still tricky even in Maven 3.0 since this is not always applicable, as noted in <a href="https://maven.apache.org/settings.html">the same doc</a>.</p>

<p><blockquote><p>Note that properties defined in profiles within the settings.xml cannot be used for interpolation.</p></blockquote></p>

<h3>Gradle</h3>

<p>In Gradle, Nexus authentication can be specified in both <code>build.gradle</code> and <code>gradle.properties</code> file, where <code>build.gradle</code> should be checked into VCS (e.g., git) while <code>gradle.properties</code> contains sensitive credentials information.</p>

<pre><code class="groovy Example build.gradle">    repositories {
        maven {
            credentials {
                username nexusUsername
                password nexusPassword
            }
            url { nexusPublic }
        }
    }
</code></pre>

<pre><code class="properties Example gradle.properties">nexusUsername=myUsername
nexusPassword=password123
nexusPublic=https://nexus.example.com/nexus/content/groups/public/
</code></pre>

<p>The default location of the <code>gradle.properties</code> file is <code>~/.gradle</code>.
This is due to the environment variable <code>GRADLE_USER_HOME</code> usually set to <code>~/.gradle</code>.
For custom location of <code>gradle.properties</code> (i.e., other than <code>~/.gradle</code>), ensure that the variable <code>GRADLE_USER_HOME</code> is set accordingly.</p>

<p>However, similar to Maven, for Jenkins pipeline automation, it is not safe to store credentials in plain text file <code>gradle.properties</code>, no matter how &ldquo;hidden&rdquo; its location is.
For that purpose, you should use the following Groovy code:</p>

<pre><code class="groovy Nexus authentication for Gradle in Jenkinsfile.">  withCredentials([
    [$class: 'StringBinding', credentialsId: 'nexusUsername', variable: 'ORG_GRADLE_PROJECT_nexusUsername'],
    [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'ORG_GRADLE_PROJECT_nexusPassword']
  ]) {
    withEnv([
      'ORG_GRADLE_PROJECT_nexusPublic=https://nexus.example.com/nexus/content/groups/public/',
      'ORG_GRADLE_PROJECT_nexusReleases=https://nexus.example.com/nexus/content/repositories/releases',
      'ORG_GRADLE_PROJECT_nexusSnapshots=https://nexus.example.com/nexus/content/repositories/snapshots'
    ]) {
      sh './gradlew jenkinsBuild'
    }
  }
</code></pre>

<p>Note that, in Gradle, the solution is much simpler because Gradle respects properies set through environment variales.
Based on <a href="https://docs.gradle.org/current/userguide/build_environment.html">its doc</a>, if the environment variable name looks like <strong><em>ORG_GRADLE_PROJECT_prop=somevalue</em></strong>, then Gradle will set a <code>prop</code> property on your project object, with the value of <code>somevalue</code>.
Therefore, in <code>withCredentials</code> step, we specifically bind the secrets <code>nexusUsername</code> and <code>nexusPassword</code> to the environment variables <em>ORG_GRADLE_PROJECT_nexusUsername</em> and <em>ORG_GRADLE_PROJECT_nexusPassword</em> and not some arbitrary variable names.
These environment variables should match the ones used in <code>builde.gradle</code> and, in the following Closure, we simply call the standard Gradle wrapper command <code>./gradlew &lt;target&gt;</code>.
Compared with Maven solution in the last section, there is no intermediate step to generate <code>settings.xml</code> based on the provided secrets.</p>

<h3>More Tips</h3>

<p>If Maven/Gradle build is used in multiple repositories across organization, it is recommended to move the above Groovy code into shared Jenkins library, as shown in <a href="/blog/2017/03/17/jenkins-pipeline-shared-libraries/">last post</a>.
For example, the Gradle builds can be simplified by defining <code>useNexus</code> step (see <a href="https://jenkins.io/doc/book/pipeline/shared-libraries/#defining-steps">here</a>) and adding it into the <a href="/blog/2017/03/17/jenkins-pipeline-shared-libraries/">shared library <em>workflow-lib</em></a>.</p>

<pre><code class="groovy vars/useNexus.groovy">def call(Closure body) {
  withCredentials([
    [$class: 'StringBinding', credentialsId: 'nexusUsername', variable: 'ORG_GRADLE_PROJECT_nexusUsername'],
    [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'ORG_GRADLE_PROJECT_nexusPassword']
  ]) {
    withEnv([
      'ORG_GRADLE_PROJECT_nexusPublic=https://nexus.example.com/nexus/content/groups/public/',
      'ORG_GRADLE_PROJECT_nexusReleases=https://nexus.example.com/nexus/content/repositories/releases',
      'ORG_GRADLE_PROJECT_nexusSnapshots=https://nexus.example.com/nexus/content/repositories/snapshots'
    ]) {
      body()
    }
  }
}
</code></pre>

<p>After that, all the Gradle builds with Nexus authentication in Jenkinsfile will now be reduced to simply this:</p>

<pre><code class="groovy Simplified Nexus authentication for Gradle in Jenkinsfile.">useNexus {
  sh './gradlew jenkinsBuild'
}
</code></pre>

<p>As shown above, it will reduce lots of redundant codes for Gradle builds, repeated again and again in Jenkinsfiles across multiple repositories in an organizaiton.</p>

<h3>References</h3>

<ul>
<li><a href="https://support.cloudbees.com/hc/en-us/articles/203802500-Injecting-Secrets-into-Jenkins-Build-Jobs">Secrets in Jenkins build jobs</a></li>
<li><a href="https://docs.gradle.org/current/userguide/build_environment.html">Gradle build environment</a></li>
<li><a href="https://stackoverflow.com/questions/12749225/where-to-put-gradle-configuration-i-e-credentials-that-should-not-be-committe">Stackoverflow dicussion</a>: for older versions of Gradle.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Groovy Script in Jenkins Pipeline]]></title>
    <link href="http://tdongsi.github.io/blog/2017/04/18/groovy-code-in-jenkins-pipeline/"/>
    <updated>2017-04-18T17:07:44-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/04/18/groovy-code-in-jenkins-pipeline</id>
    <content type="html"><![CDATA[<p>In this post, we look into loading and reusing independent Groovy scripts for more modular and testable Jenkins pipeline.
An example with Scripted Pipeline is provided although it is also applicable to newer Declarative Pipeline with minor modifications.</p>

<!--more-->


<h3>Basic example of Loading Groovy scripts</h3>

<pre><code class="plain script example.groovy">def example1() {
  println 'Hello from example1'
}

def example2() {
  println 'Hello from example2'
}

return this
</code></pre>

<p>The <code>example.groovy</code> script defines <code>example1</code> and <code>example2</code> functions before ending with <code>return this</code>.
Note that <code>return this</code> is definitely required and one common mistake is to forget ending the Groovy script with it.</p>

<pre><code class="groovy Jenkinsfile">def code

node('java-agent') {
  stage('Checkout') {
    checkout scm
  }

  stage('Load') {
    code = load 'example.groovy'
  }

  stage('Execute') {
    code.example1()
  }
}

code.example2()
</code></pre>

<p>In Jenkinsfile, simply use <a href="https://jenkins.io/doc/pipeline/steps/workflow-cps/#load-evaluate-a-groovy-source-file-into-the-pipeline-script"><code>load</code> step</a> to load the Groovy script.
After the Groovy script is loaded, the functions insides can be used where it can be referenced, as shown above.</p>

<h3>Demo: Processing Github JSON from Groovy</h3>

<p>In this demo, we first show how to process JSON response from Github API in Groovy.</p>

<pre><code class="groovy Processing JSON from Github">String username = System.getenv('GITHUB_USERNAME')
String password = System.getenv('GITHUB_PASSWORD')

String GITHUB_API = 'https://api.github.com/repos'
String repo = 'groovy'
String PR_ID = '2' // Pull request ID

String url = "${GITHUB_API}/${username}/${repo}/pulls/${PR_ID}"
println "Querying ${url}"
def text = url.toURL().getText(requestProperties: ['Authorization': "token ${password}"])
def json = new JsonSlurper().parseText(text)
def bodyText = json.body

// Check if Pull Request body has certain text
if ( bodyText.find('Safari') ) {
    println 'Found Safari user'
}
</code></pre>

<p>The equivalent bash command for retrieving JSON response from Github API is as follows:</p>

<pre><code class="plain Equivalent bash command">// Groovy formatted string
String cmd = "curl -s -H \"Authorization: token ${password}\" ${url}"

// Example
String example = 'curl -s -H "Authorization: token XXX" https://api.github.com/repos/tdongsi/groovy/pulls/2'
</code></pre>

<h3>Processing Github JSON from Jenkinsfile</h3>

<p>Continuing the demo from the last section, we now put the Groovy code into a callable function in a script called &ldquo;github.groovy&rdquo;.
Then, in our Jenkinsfile, we proceed to load the script and use the function to process JSON response from Github API.</p>

<pre><code class="groovy github.groovy">import groovy.json.JsonSlurper

def getPrBody(String githubUsername, String githubToken, String repo, String id) {
  String GITHUB_API = 'https://api.github.com/repos'

  String url = "${GITHUB_API}/${githubUsername}/${repo}/pulls/${id}"
  println "Querying ${url}"
  def text = url.toURL().getText(requestProperties: ['Authorization': "token ${githubToken}"])
  def json = new JsonSlurper().parseText(text)
  def bodyText = json.body

  return bodyText
}

return this
</code></pre>

<pre><code class="groovy Jenkinsfile">def code

node('java-agent') {
  stage('Checkout') {
    checkout scm
  }

  stage('Load') {
    code = load 'github.groovy'
  }

  stage('Execute') {
    withCredentials([
      [$class: 'UsernamePasswordMultiBinding', credentialsId: 'githubCredentials', 
      passwordVariable: 'GITHUB_PASSWORD', usernameVariable: 'GITHUB_USERNAME']
    ]) {

      def bodyText = code.getPrBody(env.GITHUB_USERNAME, env.GITHUB_PASSWORD, 
                                    'Groovy4Jenkins', env.CHANGE_ID)
      println bodyText

    }
  }
}
</code></pre>

<h3>Troubleshooting tips</h3>

<p>When loading and running Groovy scripts, you might find yourself running to RejectedAccessException errors.
In those cases, usually it can be resolved by manually approving some method signatures in <strong>Jenkins > Manage Jenkins > In-process Script Approval</strong> page.
Adminstrators privilege is required for doing so.</p>

<p>More troubleshooting information is listed in this <a href="/blog/2017/06/16/troubleshooting-groovy-scripts-in-jenkinsfile/">blog post</a>.</p>

<h3>Reference</h3>

<ul>
<li><a href="https://github.com/jenkinsci/pipeline-examples/tree/master/pipeline-examples/load-from-file">JenkinsCI example</a></li>
<li><a href="https://jenkins.io/doc/pipeline/steps/workflow-cps/#load-evaluate-a-groovy-source-file-into-the-pipeline-script"><code>load</code> step</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins Pipeline Shared Libraries]]></title>
    <link href="http://tdongsi.github.io/blog/2017/03/17/jenkins-pipeline-shared-libraries/"/>
    <updated>2017-03-17T15:38:14-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/03/17/jenkins-pipeline-shared-libraries</id>
    <content type="html"><![CDATA[<p>When you have multiple Pipeline jobs, you often want to share some parts of the Jenkinsfiles between them to keep Jenkinfiles <a href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>.
A very common use case is that you have many projects that are built in the similar way, such as Nexus authentication step in Gradle build.
One way is to use <a href="https://github.com/jenkinsci/workflow-cps-global-lib-plugin">Workflow plugin</a>.
Comprehensive user documentation can be found in <a href="https://jenkins.io/doc/book/pipeline/shared-libraries/">this section</a> of Jenkins handbook.</p>

<p>In the following sections, we review a couple <strong>older</strong>, but not necessarily worse, ways of updating shared Groovy code which are still used in some Jenkins system.</p>

<!--more-->


<h3>Simple copying</h3>

<p>A quick and dirty way of updating shared Groovy codes in Jenkinsfile is to overwrite Groovy files on Jenkins in its <code>$JENKINS_HOME</code>.
All such Groovy files are stored in <em>$JENKINS_HOME/workflow-libs</em> folder, following this directory structure:</p>

<pre><code class="plain Directory structure of a Shared Library repository">(root)
+- src                     # Groovy source files
|   +- org
|       +- foo
|           +- Bar.groovy  # for org.foo.Bar class
+- vars
|   +- foo.groovy          # for global 'foo' variable
|   +- foo.txt             # help for 'foo' variable
+- resources               # resource files (external libraries only)
|   +- org
|       +- foo
|           +- bar.json    # static helper data for org.foo.Bar
</code></pre>

<p>By manually modifying the Groovy files (e.g., <em>vars/foo.groovy</em>) and restarting Jenkins, you can update their behaviors accordingly.
This method is dirty and definitely bad since it requires a Jenkins restart and modifications to Groovy codes are not tracked (and code-reviewed) anywhere.</p>

<h3>Git-based update</h3>

<p>A more scalable alternative for updating Groovy codes is to use <code>git push</code>, exposed by Jenkins.</p>

<p>As a side note, this method is no longer mentioned in documentation, as of March 2017.
In fact, you have to look into a <a href="https://github.com/jenkinsci/workflow-cps-global-lib-plugin/tree/ce1177278d4cb05ac6b01f723177cc4b2e0aec8d">very old commit</a>
or <a href="https://github.com/cloudbees/workflow-plugin/tree/master/cps-global-lib">outdated, unofficial fork</a> to find this method briefly mentioned at all.
It is also occasionally mentioned in support articles such as <a href="https://support.cloudbees.com/hc/en-us/articles/218162277-Unable-to-Clone-workflowLibs">this</a>.</p>

<p>In this method, the directory <em>$JENKINS_HOME/workflow-libs</em> is exposed by Jenkins as a Git repository.
You can deploy new changes to this directory through <code>git push</code> and any such event will trigger Jenkins to recompile Groovy files.
There is no Jenkins restart required for this method, which makes it much more suitable for production Jenkins.
The Git repository is exposed in two endpoints:</p>

<ul>
<li><a href="http://server/jenkins/workflowLibs.git">http://server/jenkins/workflowLibs.git</a> (when your Jenkins is <code>http://server/jenkins/</code>).</li>
<li>ssh://USERNAME@server:PORT/workflowLibs.git (when Jenkins acts as <a href="https://wiki.jenkins-ci.org/display/JENKINS/Jenkins+SSH">an SSH server</a>)</li>
</ul>


<p>This method also means that the shared Jenkins library scripts in Groovy are stored in another Git repository (e.g., &ldquo;shared-lib&rdquo; on Github) and only <code>git push</code> to the <code>workflowLibs.git</code> repository in the event of deployment.
Having the shared scripts in Git allows you to track changes, perform tested deployments, and reuse the same shared library across a large number of instances.</p>

<h4>Jenkinsfile to update global library</h4>

<p>In this Git-based update approach, all Groovy files should be in some Git repository (e.g., &ldquo;shared-lib&rdquo;) with certain directory structure (shown in the last section).
Since Jenkinsfile has been extensively used for creating CI/CD pipelines, it is only appropriate to add a Jenkinsfile for deploying Groovy files in this Git repository to update Jenkins.
The Jenkinsfile for such workflow-libs should be as follows:</p>

<pre><code class="plain Jenkinsfile for deployment">  stage 'Checkout'
  checkout scm

  if (env.BRANCH_NAME == 'master') {
    stage 'Update'
    println "Updating Jenkins workflow-libs"
    sshagent(['jenkins_ssh_key']) {
      sh """
         git branch master
         git checkout master
         ssh-keyscan -H -p 12222 \${JENKINS_ADDR} &gt;&gt; ~/.ssh/known_hosts
         git remote add jenkins ssh://tdongsi@\${JENKINS_ADDR}:12222/workflowLibs.git
         git push --force jenkins master
      """
    }
  }
</code></pre>

<p>Some comments on this Jenkinsfile:</p>

<ul>
<li><code>sshagent(['jenkins_ssh_key'])</code> indicates that the current node/slave is known as <a href="https://wiki.jenkins-ci.org/display/JENKINS/SSH+Agent+Plugin">an SSH agent</a> to Jenkins master, using Jenkins credentials with ID <code>jenkins_ssh_key</code>.</li>
<li><code>git remote add</code> uses the currently checked out Git repo and branch as a remote branch (named &ldquo;jenkins&rdquo;) to the <code>workflowLibs</code> repository.</li>
<li>The <code>workflowLibs</code> repository is managed by Jenkins, exposed at that location <em>ssh://tdongsi@\${JENKINS_ADDR}:12222/workflowLibs.git</em>.</li>
<li>Then we force push any new changes to the Git repository on Jenkins.</li>
</ul>


<p>After the push, the Git repository <code>workflowLibs</code> on Jenkins should have latest change, same as the current &ldquo;shared-lib&rdquo; repository.
Upon a <code>git push</code> event, the Jenkins will automatically update its global library with the latest changes, without the need of restarting.
Note that for this SSH push to work, a public-private key pair must be generated and configured accordingly.</p>

<pre><code class="plain Key pair generation">mymac:jenkins tdongsi$ kubectl --namespace=jenkins exec -ti jenkins-ideb4 -- bash

jenkins@jenkins-4076880321-ideb4:~$ ssh-keygen -t rsa -b 4096 -C "example@gmail.com"
Generating public/private rsa key pair.
Enter file in which to save the key (/var/jenkins_home/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
</code></pre>

<p>The generated public key should be added to the user via <em>jenkinsurl.com/user/tdongsi/configure</em> URL and private key should be added to the credentials ID <code>jenkins_ssh_key</code>.</p>

<h3>References</h3>

<ul>
<li><a href="https://github.com/cloudbees/workflow-plugin/tree/master/cps-global-lib">Git-based update</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
