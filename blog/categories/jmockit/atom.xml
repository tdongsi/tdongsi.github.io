<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jmockit | Personal Programming Notes]]></title>
  <link href="http://tdongsi.github.io/blog/categories/jmockit/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/"/>
  <updated>2016-02-21T12:37:20-08:00</updated>
  <id>http://tdongsi.github.io/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Use JMockit ONLY]]></title>
    <link href="http://tdongsi.github.io/blog/2016/02/21/java-1-single-mocking-framework/"/>
    <updated>2016-02-21T12:20:46-08:00</updated>
    <id>http://tdongsi.github.io/blog/2016/02/21/java-1-single-mocking-framework</id>
    <content type="html"><![CDATA[<p>The more generic title should be &ldquo;Use a single mocking framework ONLY&rdquo;.
Personally, it means that I should stop learning Wiremock&rsquo;s advanced features and learn JMockit (specifically JMockit 1.21) which is used at work.</p>

<p>We know that mocking is a critical enabler for unit tests and automated functional tests that donâ€™t require networks and databases and can complete in reasonable time.
Mocking tools work by integrating with and replacing critical parts of the Java Class Loader.
It means that having multiple mocking tools in use will lead to those tools contend to replace the class loader in JVM.
This will lead to complex and unexpected consequences and, as a result, random test failures and unreliable tests.
We might have tests that work fine locally but start failing when running in combination with others in unexpected order because different mocking frameworks take over the class loader in different order or in different ways.</p>

<p>To fix that, we need to standardize and settle on a single mocking framework for an organization or a project.</p>
]]></content>
  </entry>
  
</feed>
