<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Testing | Personal Programming Notes]]></title>
  <link href="http://tdongsi.github.io/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/"/>
  <updated>2018-10-01T23:53:32-07:00</updated>
  <id>http://tdongsi.github.io/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jenkins Pipeline Unit Testing]]></title>
    <link href="http://tdongsi.github.io/blog/2018/06/07/jenkins-pipeline-unit-testing/"/>
    <updated>2018-06-07T22:33:46-07:00</updated>
    <id>http://tdongsi.github.io/blog/2018/06/07/jenkins-pipeline-unit-testing</id>
    <content type="html"><![CDATA[<p><a href="https://jenkins.io/doc/book/pipeline/shared-libraries/">Jenkins shared library</a> is a powerful way for sharing Groovy code between multiple Jenkins pipelines.
However, when many Jenkins pipelines, including mission-critical deployment pipelines, depend on such shared libraries, automated testing becomes necessary to prevent regressions whenever new changes are introduced into shared librariers.
Despite its drawbacks, the third-party <a href="https://github.com/jenkinsci/JenkinsPipelineUnit">Pipeline Unit Testing framework</a> satisfies some of automated testing needs.
It would allow you to do mock execution of pipeline steps and checking for expected behaviors before actually running in Jenkins.
However, documentation for this third-party framework is severely lacking (mentioned briefly <a href="https://jenkins.io/doc/book/pipeline/development/#unit-test">here</a>) and it is one of many reasons that unit testing for Jenkins shared libraries is usually an after-thought, instead of being integrated early.
In this blog post, we will see how to do unit testing for Jenkins shared library with the Pipeline Unit Testing framework.</p>

<!--more-->


<h3>Testing Jenkins shared library</h3>

<h4>Example Groovy file</h4>

<p>For this tutorial, we look at the following Groovy build wrapper as the example under test:</p>

<pre><code class="groovy buildWrapper.groovy">def call(Closure body) {
  def config = [:]

  if (body != null) {
    body.resolveStrategy = Closure.DELEGATE_FIRST
    body.delegate = config
    body()
  }

  def settings = config.settings ?: "settings.xml"

  node('java-agent') {
    stage('Checkout') {
      checkout scm
    }

    stage('Main') {
      // Test Python setup
      sh(script: 'python -c "import requests"', returnStatus: true)
      // Test Docker setup
      sh 'docker version'
    }

    stage('Post') {
      // Print info of standard tools
      sh 'ls -al'
      sh 'java -version'
      sh "mvn -s $settings -version"
      sh 'python -V'
    }
  }
}
</code></pre>

<p>After the shared library is set up properly, you can call the above Groovy build wrapper in Jenkinsfile as follows to use default parameters:</p>

<pre><code class="groovy Jenkinsfile for first use case ">buildWrapper {
}
</code></pre>

<p>or you can set the parameters in the wrapper&rsquo;s body as follows:</p>

<pre><code class="groovy Jenkinsfile for second use case">buildWrapper {
  settings = "dummy.xml"
}
</code></pre>

<p>In the next section, we will look into automated testing of both use cases using JenkinsPipelineUnit.</p>

<h4>Using JenkinsPipelineUnit</h4>

<p>To use JenkinsPipelineUnit, it is recommended to set up IntelliJ following <a href="/blog/2018/02/09/intellij-setup-for-jenkins-shared-library-development/">this tutorial</a>.</p>

<p>To test the above <code>buildWrapper.groovy</code> using the Jenkins Pipeline Unit, you can start with a unit test for the second use case as follows:</p>

<pre><code class="groovy">  /**
   * Represent the call:
   *     buildWrapper {
   *       settings = "dummy.xml"
   *     }
   *
   * @throws Exception
   */
  @Test
  public void configured() throws Exception {
    def script = loadScript('vars/buildWrapper.groovy')
    script.call({
      settings = "dummy.xml"
    })

    printCallStack()
  }
</code></pre>

<p>Unfortunately, when executing that unit test, it is very likely that you will get various errors that are not well-explained by JenkinsPipelineUnit documentation.</p>

<pre><code class="plain Stack trace">groovy.lang.MissingPropertyException: No such property: scm for class: demoWrapper

    at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:66)
    at org.codehaus.groovy.runtime.callsite.PogoGetPropertySite.getProperty(PogoGetPropertySite.java:51)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGroovyObjectGetProperty(AbstractCallSite.java:310)
    at demoWrapper$_call_closure1$_closure2.doCall(demoWrapper.groovy:19)
</code></pre>

<p>The short explanation is that the mock execution environment is not properly set up.
First, we need to call <code>setUp()</code> from the base class BaseRegressionTest of JenkinsPipelineUnit to set up the mock execution environment.
In addition, since most Groovy scripts will have this statement <code>checkout scm</code>, we need to <a href="https://github.com/jenkinsci/JenkinsPipelineUnit#mock-jenkins-variables">mock the Jenkins global variable</a> <code>scm</code>, which represents the SCM state (e.g., Git commit) associated with the current Jenkinsfile.
The most simple way to mock it is to set it to empty state as follows:</p>

<pre><code class="groovy Mocking Jenkins variable scm">binding.setVariable('scm', [:])
</code></pre>

<p>We can also set it to a more meaningful value such as a Git branch as follows:</p>

<pre><code class="groovy Mocking Jenkins variable scm">    binding.setVariable('scm', [
        $class: 'GitSCM',
        branches: [[name: 'master']],
        doGenerateSubmoduleConfigruations: false,
        extensions: [],
        submoduleCfg: [],
        userRemoteConfigs: [[url: "/var/git-repo"]]
    ])
</code></pre>

<p>However, an empty <code>scm</code> will usually suffice.
Besides Jenkins variables, we can also <a href="https://github.com/jenkinsci/JenkinsPipelineUnit#mock-jenkins-commands">register different Jenkins steps/commands</a> as follows:</p>

<pre><code class="groovy Mocking Jenkins step library">helper.registerAllowedMethod('library', [String.class], null)
</code></pre>

<p>After going through the setup steps above, you should have the following setup method like this:</p>

<pre><code class="groovy Minimum setup method">import com.lesfurets.jenkins.unit.BaseRegressionTest

class DemoTest extends BaseRegressionTest {

  @Override
  @Before
  public void setUp() throws Exception {
    super.setUp();
    binding.setVariable('scm', [:])
    helper.registerAllowedMethod('library', [String.class], null)
  }
...
}
</code></pre>

<p>Rerunning the above unit test will show the full stack of execution:</p>

<pre><code class="plain">   buildWrapper.call(groovy.lang.Closure)
      buildWrapper.node(java-agent, groovy.lang.Closure)
         buildWrapper.stage(Checkout, groovy.lang.Closure)
            buildWrapper.checkout({})
         buildWrapper.stage(Main, groovy.lang.Closure)
            buildWrapper.sh({script=python -c "import requests", returnStatus=true})
            buildWrapper.sh(docker version)
         buildWrapper.stage(Post, groovy.lang.Closure)
            buildWrapper.sh(ls -al)
            buildWrapper.sh(java -version)
            buildWrapper.sh(mvn -s dummy.xml -version)
            buildWrapper.sh(python -V)
</code></pre>

<p>For automated detection of regression, we need to save the expected call stack above into a file into a location known to JenkinsPipelineUnit.
You can specify the location of such call stacks by overriding the field <code>callStackPath</code> of BaseRegressionTest in <code>setUp</code> method.
The file name should follow the convention <code>${ClassName}_${subname}.txt</code> where <code>subname</code> is specified by <code>testNonRegression</code> method in each test case.
Then, you can update the above test case to perform regression check as follows:</p>

<pre><code class="groovy">  @Test
  public void configured() throws Exception {
    def script = loadScript('vars/demoWrapper.groovy')
    script.call({
      settings = "dummy.xml"
    })

    // printCallStack()
    testNonRegression("configured")
  }
</code></pre>

<p>In this example, the above call stack should be saved into <code>DemoTest_configured.txt</code> file at the location specified by <code>callStackPath</code>.
Similarly, you can also have another unit test for the other use case of <code>buildWrapper</code>.</p>

<pre><code class="groovy">  /**
   * Represent the call:
   * buildWrapper {
   * }
   *
   * @throws Exception
   */
  @Test
  public void default_value() throws Exception {
    def script = loadScript('vars/buildWrapper.groovy')
    script.call({})

    // printCallStack()
    testNonRegression("default")
  }
</code></pre>

<p>This <a href="https://github.com/tdongsi/jenkins-steps-override/blob/master/test/vars/BuildWrapperTest.groovy">example class</a> shows a complete example, together with <a href="https://github.com/tdongsi/jenkins-steps-override/tree/master/test/vars/callstacks">files of expected call stacks</a>.</p>

<p>TODO: View diff in IntelliJ.</p>

<h3>Other usage</h3>

<p>You can also use PipelineUnitTests to test Jenkinsfile.
In most cases, testing Jenkinsfile will be similar to testing Groovy files in <code>vars</code> folder, as explained above, since they are quite similar.</p>

<pre><code class="groovy Example Jenkinsfile">node() {
  stage('Checkout') {
    checkout scm
    sh 'git clean -xdf'
  }

  stage('Build and test') {
    sh './gradlew build'
    junit 'build/test-results/test/*.xml'
  }
}
</code></pre>

<p>The process is very similar: you need to mock out some global variables and functions corresponding to Jenkins pipeline steps.
You will need to <code>printCallStack</code> to obtain the expected output and save it into some text file.
Then, you can use <code>testNonRegression</code> for automated verification of no-regression in Jenkinsfile.</p>

<p>However, unlike Groovy files in <code>vars</code> folder, Jenkinsfiles are regularly updated and usually NOT used by any other codes.
Therefore, automated tests for Jenkinsfile are not very common because of the cost/effort required.</p>

<h3>References</h3>

<ul>
<li><a href="https://github.com/jenkinsci/JenkinsPipelineUnit">JenkinsPipelineUnit</a></li>
<li><a href="https://www.youtube.com/watch?v=RmrpUtbVR7o">The talk at Jenkins World 17</a></li>
<li><a href="https://github.com/tdongsi/jenkins-steps-override">Example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unit Tests Pass on Local but Fail on CI]]></title>
    <link href="http://tdongsi.github.io/blog/2016/06/30/java-intermittent-test-failures/"/>
    <updated>2016-06-30T17:51:13-07:00</updated>
    <id>http://tdongsi.github.io/blog/2016/06/30/java-intermittent-test-failures</id>
    <content type="html"><![CDATA[<p>We have all seen it before: intermittent unit test failures.
It could be agonizing that unit tests pass locally, but then fail in the Jenkins unit test build.</p>

<!--more-->


<p>In our experience, one of the most common causes is:
<strong>static initialization code that dynamically sets a static member variable from a config file value.</strong></p>

<p>What happens locally?
If you’re running from the command line, you probably have some environment variables set.
These allow some ConfigHelper class to find the resource properties files and load them.
In the end, code that looks like the following often ends up succeeding:</p>

<pre><code class="java DbQueue class">private static final String MY_CONFIG = ConfigHelper.getBoolean("config_key", false);
</code></pre>

<p>But the unit tests on the CI server run without being set up for a Tomcat application server run.
Instead, they run using some mock framework such as JMockit.
Mocking in this scenario is a good, desirable thing.
However, it also means that code like that ends up failing to find those resources.
In the example above, the class <code>DbQueue</code>&rsquo;s static code was invoked <strong>even though the class itself has been mocked out</strong>.
And very often, classes like that throw some misleading exceptions, especially when trying to load and convert to a numeric value from a resource.</p>

<p>So, how do we fix it?
How do we prevent that class static member initialization code from being invoked in Jenkins test build?
The answer is when we mock the class in JMockit using the <code>@Mocked</code> annotation, we can provide the <code>stubOutClassInitialization=true</code> parameter, like this:</p>

<pre><code class="java Mock with JMockit">public class MyTest {
    @Mocked( stubOutClassInitialization = true )
    DbQueue queue;

    ...
}
</code></pre>

<p>That will prevent the static code in the class <code>DbQueue</code> from running in Jenkins unit test builds.
The additional benefit of doing this <em>correctly</em> and <em>completely</em> is that we’ll be able to run our unit tests from inside Eclipse WITHOUT setting the <code>–DSBNHOME=</code> environment variable and the test will still complete as desired.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java: Unit Test Performance]]></title>
    <link href="http://tdongsi.github.io/blog/2016/06/06/java-unit-test-performance/"/>
    <updated>2016-06-06T22:47:42-07:00</updated>
    <id>http://tdongsi.github.io/blog/2016/06/06/java-unit-test-performance</id>
    <content type="html"><![CDATA[<p>According to <a href="https://www.youtube.com/watch?v=wEhu57pih5w">this</a>, the right way of automated testing is that we have lots of unit tests as majority of our overall automated tests, supplemented by a smaller set of functional tests and even fewer sets of integration tests (a.k.a., Test Automation Pyramid).
However, for that strategy to work, we should pay attention to unit test performance.
It is not productive for us developers to wait 30+ minutes to run unit tests locally, especially when we have multiple check-ins per day.
In addition, the runtime will get compounded as we add more unit tests.
Here, I list out few commonly observed mistakes to avoid and suggestions that frequently improve Java unit test performance.</p>

<!--more-->


<p>1) Do NOT add loggings/printing to your tests.
Use TestNG assertions instead of checking screen output.
Remove from the test classes all the <code>System.out.println</code> statements (that we might add when we start writing unit tests).
The logs don&rsquo;t matter when we&rsquo;re running in parallel.
Moreover, it could add 5-10 minutes to the build time, regardless of running in sequential or parallel.</p>

<p>2) Another common mistake is to override the default <code>System.out</code> by calling <code>System.setOut(PrintStream)</code> and verify by asserting against log statements.
This tactic is often used to verify expected method invocations, which will subsequently generate some specific log entries.
For such behavior testing, consider using <a href="https://jmockit.googlecode.com/svn-history/r2056/trunk/www/tutorial/BehaviorBasedTesting.html">Jmockit Verifications</a> instead of depending on output of logs generated.</p>

<p>3) Mock logging and config classes if applicable.
Otherwise, we might encountered errors like &ldquo;Exception encountered, logging will be disabled&rdquo;, probably thrown by JMockit.
If there is any static initialization block in the mocked class for logging and configuration purposes, consider using <code>(stubOutClassInitialization = true)</code> (see <a href="/blog/2016/06/30/java-intermittent-test-failures/">this</a>).</p>

<p>4) Choosing the right parallel execution settings can substantially improve the execution time.
However, for parallel test runs, consider splitting big test classes (> 100 tests) that are taking much longer than others.
As we are running test classes in parallel across multiple JVMs, it is often the case that all JVMs are shut down except for one or two which are running some big test classes.
Splitting those classes into multiple smaller classes will distribute the load equally across multiple JVMs.</p>

<p>5) Out of all the <code>maven-surefire</code> options for running tests in parallel, the one that worked considering JMockit limitations with parallel execution (and our test structure) are as below:</p>

<pre><code class="xml Maven-surefire options">&lt;parallel&gt;classes&lt;/parallel&gt;
&lt;forkCount&gt;${forkCount}&lt;/forkCount&gt;
&lt;reuseForks&gt;false&lt;/resuseForks&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use One Mocking Framework ONLY]]></title>
    <link href="http://tdongsi.github.io/blog/2016/02/21/java-1-single-mocking-framework/"/>
    <updated>2016-02-21T12:20:46-08:00</updated>
    <id>http://tdongsi.github.io/blog/2016/02/21/java-1-single-mocking-framework</id>
    <content type="html"><![CDATA[<p>We know that mocking is a critical enabler for unit tests and automated functional tests that don’t require networks and databases and can complete in reasonable time.
In a large corporate such as Intuit, different business groups tend to adopt different mocking tools/frameworks for their development and test automation needs.
The choice of mocking framework is usually decided by personal preference and experience of few key members of development/automation team.
Mocking tools work by integrating with and replacing critical parts of the Java Class Loader.
It means that having multiple mocking tools in use will lead to those tools contend to replace the class loader in JVM.
This will lead to complex and unexpected consequences and, as a result, random test failures and unreliable tests.
For example, we might have tests that work fine locally but start failing when running in combination with others (using other mocking tools) because different mocking frameworks take over the class loader in different order or in different ways.</p>

<p>To fix that, we need to standardize and settle early on a single mocking framework for an organization or a project.
Sadly, this is often overlooked before it is too late.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mocking Current Date and Time in Python]]></title>
    <link href="http://tdongsi.github.io/blog/2016/01/27/python-1-mock-datetime-freezegun/"/>
    <updated>2016-01-27T17:36:53-08:00</updated>
    <id>http://tdongsi.github.io/blog/2016/01/27/python-1-mock-datetime-freezegun</id>
    <content type="html"><![CDATA[<p>In this post, we looks into unit testing some calendar utilities in Python.
A requirement for unit testing those is to &ldquo;mock&rdquo; current date and time, i.e., overriding those returned by <code>today</code> and <code>now</code> methods with some specific date values (e.g., a date in future).</p>

<!--more-->


<h3>Calendar types</h3>

<p>What is a big deal about calendar utitlities?
There are surprisingly many types of calendar.
Some of them are: regular calendar, lunar calendar, fiscal calendar, retail calendar.
See <a href="https://github.com/tdongsi/calendars">here</a> for more information of each calendar type.
Out of the above calendar types, retail calendar seems to have more complex rules.
However, this calendar type is frequently used in industries like retail and manufacturing for ease of planning around it.</p>

<h3>Mocking current time in Python</h3>

<p>Due to retail calendar&rsquo;s desirable characteristics, we may have code that work with retail calendars in commercial applications eventually.
I ended up working with a utility Python module for retail calendar with functions which return values based on current time/date.
For example, a utility function to check if a given date is in the current 544 year works like this:</p>

<pre><code class="python Original version">def is_current_year_544(given_date):
    my_today = datetime.date.today()
    if year_start_544(my_today) &lt;= given_date &lt;= year_end_544(my_today):
        return "Y"
    else:
        return "N"
</code></pre>

<p>Some utility functions in that module are even more complicated than this example function.
For those, I think calling <code>today</code> or <code>now</code> inside those functions is a bad design.
They are essentially another <em>variable</em> in those functions (i.e., when do you run?), and it is better to expose that variable as an input parameter.
In addition, being able to specify what &ldquo;today&rdquo; or &ldquo;now&rdquo; value is will make automated unit testing easier.
For example, I want to know how my Python programs work if it runs on a particular date, such as end of retail year July 29, 2006.
A probably better, more testable function would be something like this.</p>

<pre><code class="python More desirable">def is_current_year_544(given_date, run_date = datetime.date.today()):
    if year_start_544(run_date) &lt;= given_date &lt;= year_end_544(run_date):
        return "Y"
    else:
        return "N"
</code></pre>

<p>However, in reality, you sometimes have to live with the original utility Python module.
Then, the workaround for unit testing is to &ldquo;mock&rdquo; current date and time, i.e., overriding those returned by <code>today</code> and <code>now</code> methods with some specific date values.
In Python, it can be done by using some mocking framework, such as illustrated <a href="http://www.voidspace.org.uk/python/mock/examples.html#partial-mocking">here</a>.
Fortunately, my life was made even easier with <a href="https://github.com/spulec/freezegun"><code>freezegun</code> library</a>.
To install <code>freezegun</code> on Mac OSX, simply run</p>

<pre><code class="plain   ">pip install freezegun
</code></pre>

<p>Using this <code>freezegun</code> library, I can easily specify my &ldquo;current date&rdquo; as &ldquo;July 29, 2006&rdquo; by adding the following decorator with some string &ldquo;2006-07-29&rdquo; for that date.</p>

<pre><code class="python Unit test with mocking">    @freeze_time("2006-07-29")
    def test_year544_end(self):
        """
        Mock today() at 2006-07-29
        """
        self._verify_544_methods()
</code></pre>

<p>For full usage of <code>freezegun</code>, refer to its <a href="https://github.com/spulec/freezegun">quickstart guide</a>.
It should be noted that <code>freezegun</code> can mock <code>datetime</code> calls from other modules and it works great for testing with <code>datetime</code> calls.
However, you might encounter some occasional failures in your unit tests when working with <code>time</code> module.
From my personal experience, in those cases, note that time zones must be accounted for when mocking with <code>time</code> module by specifying <code>tz_offset</code> in the decorator <code>freeze_time</code>.</p>

<h3>External Links</h3>

<ul>
<li><a href="https://github.com/spulec/freezegun">freeze_gun</a></li>
<li><a href="https://en.wikipedia.org/wiki/4%E2%80%934%E2%80%935_calendar">Retail Calendar</a></li>
<li><a href="http://www.staff.science.uu.nl/~gent0113/calendar/isocalendar.htm">ISO Calendar</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
