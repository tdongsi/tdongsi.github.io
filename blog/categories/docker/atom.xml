<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Docker | Personal Programming Notes]]></title>
  <link href="http://tdongsi.github.io/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/"/>
  <updated>2017-06-12T14:13:33-07:00</updated>
  <id>http://tdongsi.github.io/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sending Emails From Docker Containers]]></title>
    <link href="http://tdongsi.github.io/blog/2017/05/25/sending-emails-from-docker-containers/"/>
    <updated>2017-05-25T13:42:45-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/05/25/sending-emails-from-docker-containers</id>
    <content type="html"><![CDATA[<p>In this post, we looks into sending notification emails at the end of CI pipelines in a containerized Jenkins system.</p>

<h3>Sending emails in standard Jenkins setup</h3>

<p>We first look at a typical Jenkins setup, where the Jenkins instance is installed directly on a host machine (VM or bare-metal) and has direct communication to the SMTP server.
For corporate network, you may have to use an SMTP relay server instead.
For those cases, you can configure SMTP communication by <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-postfix-as-a-send-only-smtp-server-on-ubuntu-14-04">setting up Postfix</a>.
Its typical settings is defined in <em>/etc/postfix/main.cf</em> file like this:</p>

<pre><code class="plain /etc/postfix/main.cf example"># See /usr/share/postfix/main.cf.bak for a commented, more complete version

myhostname = dev-worker-1.example.com
smtpd_banner = $myhostname ESMTP $mail_name
biff = no

# appending .domain is the MUA's job.
append_dot_mydomain = no

# Uncomment the next line to generate "delayed mail" warnings
#delay_warning_time = 4h

readme_directory = no

# TLS parameters
smtpd_tls_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
smtpd_tls_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
smtpd_use_tls=yes

# See /usr/share/doc/postfix/TLS_README.gz in the postfix-doc package for
# information on enabling SSL in the smtp client.


alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases
myorigin = dev-worker-1.example.com
mydestination = dev-worker-1.example.com, localhost.example.com, localhost
relayhost = smtprelay-prd.example.com
mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128
mailbox_size_limit = 0
recipient_delimiter = +
inet_interfaces = localhost
inet_protocols = all
</code></pre>

<p>We can test the setup by sending a test email with the following command:</p>

<pre><code class="plain Send a test email">[tdongsi@dev-worker-1 ~]# echo "Test localhost" | mailx -s Test tdongsi@example.com
send-mail: warning: inet_protocols: disabling IPv6 name/address support: Address family not supported by protocol
postdrop: warning: inet_protocols: disabling IPv6 name/address support: Address family not supported by protocol
</code></pre>

<p>After the <code>postfix</code> service is up, Jenkins can be configured to send email with <a href="https://wiki.jenkins-ci.org/display/JENKINS/Mailer">Mailer plugin</a>.
Mail server can be configured in <strong>Manage Jenkins</strong> page, <strong>E-mail Notification</strong> section.
Please visit <a href="http://www.nailedtothex.org/roller/kyle/entry/articles-jenkins-email">this post</a> for more detailed instructions and screenshots.
We can also test the configuration by sending test e-mail in the same <strong>E-mail Notification</strong> section.</p>

<h3>Sending email from container</h3>

<p>Many Jenkins-based CI systems have been containerized and deployed on Kubernetes cluster (in conjunction with <a href="https://wiki.jenkins-ci.org/display/JENKINS/Kubernetes+Plugin">Kubernetes plugin</a>).
For email notifications in such CI systems, one option is to reuse <code>postfix</code> service, which is usually configured and ready on the Kubernetes nodes, and expose it to the Docker containers.</p>

<p>There are two changes need to be made on Postfix to expose it to Docker containers on one host.</p>

<ol>
<li>Exposing Postfix to the docker network, that is, Postfix must be configured to bind to localhost as well as the docker network.</li>
<li>Accepting all incoming connections which come from any Docker containers.</li>
</ol>


<p>Docker bridge (<code>docker0</code>) acts a a bridge between your ethernet port and docker containers so that data can go back and forth.
We achieve the first requirement by adding the IP of <code>docker0</code> to <code>inet_iterfaces</code>.</p>

<pre><code class="plain ifconfig example output">[centos@dev-worker-1 ~]$ ifconfig
docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1472
        inet 172.22.91.1  netmask 255.255.255.0  broadcast 0.0.0.0
        ether 02:42:88:5f:24:28  txqueuelen 0  (Ethernet)
        RX packets 8624183  bytes 18891507332 (17.5 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 15891332  bytes 16911210191 (15.7 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

flannel0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1472
        inet 172.22.91.0  netmask 255.255.0.0  destination 172.22.91.0
        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 500  (UNSPEC)
        RX packets 10508237  bytes 7051646109 (6.5 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 15511583  bytes 18744591891 (17.4 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>

<p>For the second requirement, the whole docker network as well as localhost should be added to <code>mynetworks</code>.
In our kubernetes setup, the docker network should be <code>flannel0</code> and its subnet&rsquo;s CIDR notation is added to the <code>mynetworks</code> line:</p>

<pre><code class="plain Modified "/etc/postfix/main.cf""># See /usr/share/postfix/main.cf.bak for a commented, more complete version

myhostname = dev-worker-1.example.com
smtpd_banner = $myhostname ESMTP $mail_name
biff = no

# appending .domain is the MUA's job.
append_dot_mydomain = no

# Uncomment the next line to generate "delayed mail" warnings
#delay_warning_time = 4h

readme_directory = no

# TLS parameters
smtpd_tls_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
smtpd_tls_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
smtpd_use_tls=yes

# See /usr/share/doc/postfix/TLS_README.gz in the postfix-doc package for
# information on enabling SSL in the smtp client.

alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases
myorigin = dev-worker-1.example.com
mydestination = dev-worker-1.example.com, localhost.example.com, localhost
relayhost = smtprelay-prd.example.com
mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 172.22.0.0/16
mailbox_size_limit = 0
recipient_delimiter = +
inet_interfaces = localhost, 172.22.91.1
inet_protocols = all
</code></pre>

<p>Note the differences in <code>inet_interfaces</code> and <code>mynetworks</code> from the last section.
One can simply enter the Docker container/Kubernetes pod to verify such setup.
Note that application <code>mailx</code> maybe not available in a container since we tend to keep the containers light-weight.
Instead, prepare a <code>sendmail.txt</code> file (based on <a href="http://docs.blowb.org/setup-host/postfix.html">this</a>) with the following SMTP commands and use <code>nc</code> to send out the email as shown below.</p>

<pre><code class="plain Send test email from container">mymac:k8s tdongsi$ kubectl --kubeconfig kubeconfig --namespace jenkins exec -it jenkins-8hgsn -- bash -il

jenkins@jenkins-8hgsn:~/test$ cat sendmail.txt
HELO x
MAIL FROM: test@example.com
RCPT TO: tdongsi@example.com
DATA
From: test@example.com
To: $YOUR_EMAIL
Subject: This is a test

The test is successful

.
quit

jenkins@jenkins-8hgsn:~/test$ nc 172.22.91.1 25 &lt;sendmail.txt
220 dev-worker-1.eng.sfdc.net ESMTP Postfix
250 dev-worker-1.eng.sfdc.net
250 2.1.0 Ok
250 2.1.5 Ok
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
250 2.0.0 Ok: queued as 1EF9E60C34
221 2.0.0 Bye
</code></pre>

<p>For containerized Jenkins system, mail server can also be configured in same <strong>Manage Jenkins</strong> page, <strong>E-mail Notification</strong> section.
The only difference is the IP/hostname provided to <strong>SMTP server</strong> option.
Instead of providing the known SMTP server&rsquo;s IP and host, one should use the IP of <code>docker0</code>, as explained above.
In the case of many nodes in Kubernetes cluster with different <code>docker0</code> IP, the Docker container of Jenkins master should reside only on one host and <code>docker0</code>&rsquo;s IP on that host should be used.</p>

<h3>References</h3>

<ul>
<li><a href="http://www.nailedtothex.org/roller/kyle/entry/articles-jenkins-email">Standard email setup in Jenkins</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-postfix-as-a-send-only-smtp-server-on-ubuntu-14-04">Setup Postfix</a></li>
<li><a href="http://docs.blowb.org/setup-host/postfix.html">Configure Postfix for Docker Containers</a></li>
<li><a href="http://satishgandham.com/2016/12/sending-email-from-docker-through-postfix-installed-on-the-host/">More on Postfix for Docker Containers</a></li>
</ul>


<pre><code class="plain postfix version used in this post">[tdongsi@dev-worker-1 ~]$ postconf -v | grep mail_version
mail_version = 2.10.1
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Troubleshooting Docker-out-of-Docker]]></title>
    <link href="http://tdongsi.github.io/blog/2017/04/26/troubleshooting-docker-out-of-docker/"/>
    <updated>2017-04-26T16:24:24-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/04/26/troubleshooting-docker-out-of-docker</id>
    <content type="html"><![CDATA[<h3>Troubleshooting</h3>

<p>Problem description: We are using &ldquo;Docker out of Docker&rdquo; approach to build Docker images in our containerized Jenkins slaves.
However, we got hit by the following issues when reusing a Jenkins slave container image.</p>

<pre><code class="plain Error message when running Docker">+ docker images
Cannot connect to the Docker daemon. Is the docker daemon running on this host?
</code></pre>

<p>The direct cause of this error message is that the socket to docker daemon does not have the right permission (incorrect group ID).</p>

<p>TODO: <a href="https://forums.docker.com/t/cannot-connect-to-the-docker-daemon-is-the-docker-daemon-running-on-this-host/8925">https://forums.docker.com/t/cannot-connect-to-the-docker-daemon-is-the-docker-daemon-running-on-this-host/8925</a></p>

<p>The current user (<code>jenkins</code> in the example) must have permissions to talk to <code>/var/run/docker.sock</code> on that system.
By convention, that permission is given to <code>root</code> user or users in <code>docker</code> group.
However, the following commands show that it is not the case.</p>

<pre><code class="plain Show GID of docker group">+ ls -l /var/run/docker.sock

srw-rw----. 1 root 992 0 Mar 14 00:57 /var/run/docker.sock
+ cat /etc/group
...
docker:x:999:jenkins
</code></pre>

<p>The expectation is:</p>

<pre><code>+ ls -l /var/run/docker.sock
srw-rw----. 1 root docker 0 Mar 14 00:57 /var/run/docker.sock
</code></pre>

<p>This is due to the container is built inside another k8s cluster.
The group <code>docker</code> happens to have the group ID 999 on that k8s cluster.
The user <code>jenkins</code>, under which Jenkins pipeline is executed, does not have the permission to access that socket <code>/var/run/docker.sock</code>.</p>

<p>By default, a unix domain socket (or IPC socket) is created at <code>/var/run/docker.sock</code>, requiring either root permission, or docker group membership.</p>

<p>For illustration, the installation steps in Ubuntu are expected to be like this:</p>

<pre><code># Install from Web
sudo curl -sSL https://get.docker.com/ | sh
sudo usermod -aG docker jenkins

# Install from apt
sudo apt-get update
sudo apt-get install -y docker-engine
sudo usermod -aG docker jenkins
</code></pre>

<p>Example Dockerfile (from <a href="http://stackoverflow.com/questions/31466812/access-docker-sock-from-inside-a-container">here</a>).
<figure class='code'><figcaption><span>Dockerfile</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FROM jenkins&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;USER root
</span><span class='line'>ENV DEBIAN_FRONTEND=noninteractive
</span><span class='line'>ENV HOME /home/jenkins
</span><span class='line'>ENV DOCKER_VERSION=1.9.1-0~trusty&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;RUN apt-get update \
</span><span class='line'>  &amp;&amp; apt-get install -y docker-engine=$DOCKER_VERSION \
</span><span class='line'>  &amp;&amp; rm -rf /var/lib/apt/lists/*&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;RUN usermod -a -G docker jenkins</span></code></pre></td></tr></table></div></figure></p>

<p>The last step <code>usermod</code> comes from the script instruction itself: &ldquo;If you would like to use Docker as a non-root user, you should now consider adding your user to the "docker&rdquo; group".</p>

<h3><code>groupadd</code> examples</h3>

<p>The following example creates a new group called apache</p>

<pre><code>$ groupadd apache
</code></pre>

<p>Make sure it is created successfully.</p>

<pre><code># grep apache /etc/group
apache:x:1004:
</code></pre>

<p>If you don’t specify a groupid, Linux will assign one automatically.
If you want to create a group with a specific group id, do the following.</p>

<pre><code>$ groupadd apache -g 9090

$ grep 9090 /etc/group
apache:x:9090:
</code></pre>

<p>Group account information is stored in <code>/etc/group</code>.</p>

<h3>References</h3>

<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/dockerd/">dockerd</a></li>
<li><a href="https://linux.die.net/man/8/groupadd">groupadd man pages</a></li>
<li><a href="http://linux.101hacks.com/unix/groupadd/">groupadd examples</a></li>
<li><a href="http://www.thegeekstuff.com/2012/06/chown-examples/">chown examples</a></li>
<li><a href="https://www.unixtutorial.org/2008/06/find-files-which-belong-to-a-user-or-unix-group/">find files with group name or ID</a></li>
</ul>


<p>TODO</p>

<ul>
<li><a href="https://github.com/docker/compose/issues/1214">https://github.com/docker/compose/issues/1214</a></li>
<li><a href="http://stackoverflow.com/questions/31466812/access-docker-sock-from-inside-a-container">http://stackoverflow.com/questions/31466812/access-docker-sock-from-inside-a-container</a></li>
<li><a href="https://github.com/jenkinsci/docker/issues/196">https://github.com/jenkinsci/docker/issues/196</a></li>
<li><a href="https://github.com/jhipster/generator-jhipster/issues/4804">https://github.com/jhipster/generator-jhipster/issues/4804</a></li>
<li><a href="https://unix.stackexchange.com/questions/33844/change-gid-of-a-specific-group">https://unix.stackexchange.com/questions/33844/change-gid-of-a-specific-group</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker: --user and --group-add Parameters]]></title>
    <link href="http://tdongsi.github.io/blog/2017/04/26/docker-user-and-group-add-parameters/"/>
    <updated>2017-04-26T10:57:51-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/04/26/docker-user-and-group-add-parameters</id>
    <content type="html"><![CDATA[<h3>Reference</h3>

<ul>
<li><a href="http://stackoverflow.com/questions/41100333/difference-between-docker-run-user-and-group-add-parameters">http://stackoverflow.com/questions/41100333/difference-between-docker-run-user-and-group-add-parameters</a></li>
<li><a href="https://github.com/jhipster/jhipster.github.io/pull/368/files">https://github.com/jhipster/jhipster.github.io/pull/368/files</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker: Files Not Found in Docker Container]]></title>
    <link href="http://tdongsi.github.io/blog/2017/02/21/docker-files-not-found-in-docker-container/"/>
    <updated>2017-02-21T15:14:43-08:00</updated>
    <id>http://tdongsi.github.io/blog/2017/02/21/docker-files-not-found-in-docker-container</id>
    <content type="html"><![CDATA[<p>I have the following Dockerfile:</p>

<pre><code>FROM docker.registry.company.net/base
MAINTAINER myemail@company.net

RUN ssh-keyscan -H github.company.net &gt;&gt; /home/jenkins/.ssh/known_hosts

RUN mkdir -p /home/jenkins/.m2 /home/jenkins/store
COPY settings.xml /home/jenkins/.m2/settings.xml

RUN openssl s_client -connect nexus.company.net:443 &lt; /dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' &gt; /home/jenkins/public.crt \
    &amp;&amp; /opt/jdk-latest/jre/bin/keytool -import -noprompt -storepass change_this -alias nexus.company.net -keystore /home/jenkins/cacerts -file /home/jenkins/public.crt
</code></pre>

<p>When I build the image with <code>docker build</code>, the commands in Dockerfile should produce several files that get dropped into the home <code>/home/jenkins</code> folder.
In fact, it can be verified in the build log that the files are created when adding additional commands.
However, when I create a container from this image using <code>docker run</code>, the files in <code>/home/jenkins</code> simply doesn&rsquo;t exist.</p>

<p>Struggling with different options of rebuilding (<code>docker build</code>) and re-running (<code>docker run</code>) gives no different outcomes.
It eventually turns out that <code>/home/jenkins</code> is mounted as a volume in the <code>base</code> image or one of its base images.</p>

<pre><code>tdongsi-ltm4:W_3703511 tdongsi$ docker inspect --format { {.Config.Volumes} } 683bb8ce246a
map[/home/jenkins:{}]
</code></pre>

<p>I can find the following lines in one of the base Dockerfiles:</p>

<pre><code>...
VOLUME /home/jenkins
WORKDIR /home/jenkins
...
</code></pre>

<p>This problem is already seen and reported in <a href="https://github.com/docker/docker/issues/3639">this issue</a>.
It happens often when we try to extend an offical image.
There is simply no way to add additional content into <code>VOLUME</code> directory in a trivial way.
There have been suggestions that <code>VOLUME</code> directive in Dockerfile is a mistake.
It should be an option/directive when running (<code>docker run</code>) not building image.</p>

<h3>References</h3>

<ul>
<li><a href="https://github.com/docker/docker/issues/3639">Reported issue</a></li>
<li><a href="http://l33t.peopleperhour.com/2015/02/18/docker-extending-official-images/">Work around</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker: Copy File Into a Container]]></title>
    <link href="http://tdongsi.github.io/blog/2017/02/09/docker-copy-file-into-a-container/"/>
    <updated>2017-02-09T15:17:19-08:00</updated>
    <id>http://tdongsi.github.io/blog/2017/02/09/docker-copy-file-into-a-container</id>
    <content type="html"><![CDATA[<p>In the following scenario, we have a running Docker container or a running pod in Kubernetes cluster.
We want to add some files into the running containers to fix some issue, verify, and commit the changes.</p>

<h3>Best-case scenario: <code>docker cp</code></h3>

<p>The most obvious way is to create a Dockerfile and rebuild the Docker image.
The Dockerfile will look like this:</p>

<pre><code class="plain Dockerfile">FROM olderImage
ADD myfile /path/myfile
...
</code></pre>

<p>However, in this approach, we need to stop the Docker containers, update, and re-run with the new Docker images.
It does not work if we want to work with <strong><em>running</em></strong> containers.
For running containers, the better way to add files into containers is to copy files into containers.
For the more updated versions of Docker (1.8+), the recommended way for copying is to use <a href="https://docs.docker.com/engine/reference/commandline/cp/"><code>docker cp</code> command</a>.</p>

<h3>Copy file directly</h3>

<p><code>docker cp</code> does not always work, especially in older versions of Docker.
In older versions of Docker, the <code>docker cp</code> command only allowed copying files from a <strong>container</strong> to the <strong>host</strong>.
Only since Docker 1.8, copying files from the host to a container is added.
You will get some error with unhelpful messages like this in older versions of Docker:</p>

<pre><code class="plain Unsupported "docker cp"">[centos@comp ~]$ ls maven_3.3.9-3_all.deb
maven_3.3.9-3_all.deb

[centos@comp ~]$ sudo docker cp maven_3.3.9-3_all.deb 9a8d782156ca:/home/jenkins
FATA[0000] Error: Path not specified
[centos@comp ~]$ sudo docker cp ./maven_3.3.9-3_all.deb 9a8d782156ca:/home/jenkins
FATA[0000] Error: Path not specified
[centos@comp ~]$ sudo docker cp ./maven_3.3.9-3_all.deb 9a8d782156ca:/home/jenkins/
FATA[0000] Error: Path not specified
[centos@comp ~]$ sudo docker cp maven_3.3.9-3_all.deb 9a8d782156ca:/home/jenkins/maven_3.3.9-3_all.deb
FATA[0000] Error: Path not specified
</code></pre>

<p>If you find yourself stuck with older versions of Docker, the alternative is to manually copy the files from hosts filesystem to containers filesystem location.
First, you need to determine where the containers filesystem (volume) is mounted on the host:</p>

<pre><code class="plain Using inspect to find Volume location">[centos@comp ~]$ sudo docker ps
CONTAINER ID      IMAGE    COMMAND ...
9a8d782156ca

[centos@comp ~]$ sudo docker inspect -f { {.Id} } 9a8d782156ca
9a8d782156ca9a3bd59545a18943de408ca58f42c4389c12e9bb43f4ad239d52

[centos@comp ~]$ sudo docker inspect -f { {.Volumes} } 9a8d782156ca
map[/home/jenkins:/var/lib/docker/vfs/dir/b051cc2b086c53ce436ad82b9332ba79687f3ddcf8ee77e3f8264e7cafe32438]
[centos@comp ~]$ sudo ls /var/lib/docker/vfs/dir/b051cc2b086c53ce436ad82b9332ba79687f3ddcf8ee77e3f8264e7cafe32438
test.txt
</code></pre>

<p>NOTE: In the shell commands above, there is no space between <code>{</code> (space is added for Jekyll blog engine).
After the mounting path is determined, you can manipulate the container'ss filesystem directly, including copying files into it.</p>

<pre><code class="plain Directly copy file into containers filesystem">[centos@comp ~]$ sudo cp maven_3.3.9-3_all.deb /var/lib/docker/vfs/dir/b051cc2b086c53ce436ad82b9332ba79687f3ddcf8ee77e3f8264e7cafe32438
</code></pre>

<p>You can verify such manipulation by <code>docker exec</code>-ing into the container and verify the files:</p>

<pre><code class="plain Before and After">jenkins@9a8d782156ca:~$ ls
test.txt

jenkins@9a8d782156ca:~$ ls
maven_3.3.9-3_all.deb  test.txt
</code></pre>

<h3>Reference</h3>

<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/cp/">docker cp</a></li>
<li><a href="http://stackoverflow.com/questions/22907231/copying-files-from-host-to-docker-container">Stackoverflow discussion</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
