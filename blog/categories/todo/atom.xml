<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Todo | Personal Programming Notes]]></title>
  <link href="http://tdongsi.github.io/blog/categories/todo/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/"/>
  <updated>2018-01-17T16:16:14-08:00</updated>
  <id>http://tdongsi.github.io/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Design Patterns for Container-based Distributed Systems]]></title>
    <link href="http://tdongsi.github.io/blog/2018/01/14/design-patterns-for-container-based-distributed-systems/"/>
    <updated>2018-01-14T14:56:56-08:00</updated>
    <id>http://tdongsi.github.io/blog/2018/01/14/design-patterns-for-container-based-distributed-systems</id>
    <content type="html"><![CDATA[<p>In earlier dates, object-oriented programming (OOP) revolutionized software development by dividing applications into modular components in memory (objects).
Today, the rise of microservice architectures and containerization technologies enable a similar revolution in developing distributed systems and SaaS/PaaS products.
&ldquo;Containers&rdquo; is analogus to &ldquo;objects&rdquo; in OOP, as a unit of development and deployment in distributed systems.
In <a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45406.pdf">this paper</a>, the authors argued that just like Design Patterns for Object-Oriented Programming, codified in the famous &ldquo;Gang of Four&rdquo; book, some Design Patterns have emerged for Container-based Distributed Systems.
In the same paper, the authors attempted to do something similar, documenting the most common patterns and their usage.</p>

<!--more-->


<h3>General ideas</h3>

<p>The container and the container image should be the abstractions for the development of distributed systems.
Similar to what objects did for OOP, thinking in term of containers abstracts away the low-level details of code and allows us to think in higher-level design patterns.
Based on how containers interact with other containers and get deployed into actual VM nodes, the authors divide the patterns in to three main groups:</p>

<ul>
<li>Single-container patterns: How to expose interface of application in container (just like object interface).

<ul>
<li>Upward direction: expose application info/metrics such as <code>/health</code> endpoint.</li>
<li>Downward direction: Formal life cycle agreed between application and management system (similar to Android Activity model).</li>
</ul>
</li>
<li>Single-node multi-container patterns: Basically, how to design a pod in Kubernetes (pod = group of symbiotic containers)

<ul>
<li>Sidecar pattern:

<ul>
<li>Sidecar containers will extend and enhance the main container.</li>
<li>Example: Log forwarding sidecar that collects logs from main container from local disk and stream to a cluster storage system.</li>
</ul>
</li>
<li>Ambassador pattern:

<ul>
<li>Ambassador containers will proxy communication to and from the main container.</li>
<li>Ambassador simplifies and standardizes the outside world to the main container.</li>
<li>Example: Redis proxy ambassador that will discover dependent services for the main container.</li>
</ul>
</li>
<li>Adapter pattern:

<ul>
<li>Adapter containers will standardize and normalize the output of the main container.</li>
<li>In contrast to ambassador, adapter simplifies and normalizes the main app to outside world.</li>
<li>Example: Adapters to ensure all containers have the same monitoring interface to hook to central monitoring system.</li>
</ul>
</li>
</ul>
</li>
<li>Multi-node patterns

<ul>
<li>Leader election pattern

<ul>
<li>When we have many replicas, but only one of them is active at a time.</li>
</ul>
</li>
<li>Work queue pattern

<ul>
<li>One coordinator and many workers distributed to as many nodes for processing.</li>
</ul>
</li>
<li>Scatter/Gather pattern

<ul>
<li>Similar to &ldquo;Work queue&rdquo; pattern, except one coordinator scatter works to many slaves, then gather/merge works from many slaves.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>References</h3>

<ul>
<li><a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_3?ie=UTF8&amp;qid=1516232505&amp;sr=8-3&amp;keywords=design+patterns">Gang of Four book</a></li>
<li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45406.pdf">Original Paper</a></li>
<li><a href="http://blog.kubernetes.io/2015/06/the-distributed-system-toolkit-patterns.html">Single-node multi-container patterns</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Class in Jenkins Shared Library]]></title>
    <link href="http://tdongsi.github.io/blog/2017/12/26/class-in-jenkins-shared-library/"/>
    <updated>2017-12-26T11:18:09-08:00</updated>
    <id>http://tdongsi.github.io/blog/2017/12/26/class-in-jenkins-shared-library</id>
    <content type="html"><![CDATA[<p>This post reviews things to keep in mind when we implement Groovy classes and/or static Groovy methods, in <code>src</code> folder as opposed to <code>vars</code> folder, for Jenkins Shared Library.</p>

<!--more-->


<h3>Recommended practices</h3>

<p>Per recommended by Jenkins documentation by CloudBees Inc., <code>src</code> folder is best for static Groovy methods.
TODO: citation needed.</p>

<h3>Accessing steps</h3>

<p>Groovy classes in Shared Jenkins library cannot directly call steps such as <code>sh</code> or <code>git</code>.
They can however implement methods, outside of the scope of an enclosing class, which in turn invoke Pipeline steps, for example:</p>

<pre><code class="groovy">// src/org/foo/Zot.groovy
package org.foo;

def checkOutFrom(repo) {
  git url: "git@github.com:jenkinsci/${repo}"
}
</code></pre>

<p>Which can then be called from a Scripted Pipeline:</p>

<pre><code class="groovy">def z = new org.foo.Zot()
z.checkOutFrom(repo)
</code></pre>

<p>This approach has limitations; for example, it prevents the declaration of a superclass.</p>

<p>Alternately, a set of steps can be passed explicitly using this to a library class, in a constructor, or just one method:</p>

<pre><code class="groovy">package org.foo
class Utilities implements Serializable {
  def steps
  Utilities(steps) {this.steps = steps}
  def mvn(args) {
    steps.sh "${steps.tool 'Maven'}/bin/mvn -o ${args}"
  }
}
</code></pre>

<p>When saving state on classes, such as above, the class must implement the Serializable interface.
This ensures that a Pipeline using the class, as seen in the example below, can properly suspend and resume in Jenkins.</p>

<pre><code>@Library('utils') import org.foo.Utilities
def utils = new Utilities(this)
node {
  utils.mvn 'clean package'
}
</code></pre>

<p>If the library needs to access global variables, such as <code>env</code>, those should be explicitly passed into the library classes, or methods, in a similar manner.</p>

<p>Instead of passing numerous variables from the Scripted Pipeline into a library,</p>

<pre><code class="groovy">package org.foo
class Utilities {
  static def mvn(script, args) {
    script.sh "${script.tool 'Maven'}/bin/mvn -s ${script.env.HOME}/jenkins.xml -o ${args}"
  }
}
</code></pre>

<p>The above example shows the script being passed in to one static method, invoked from a Scripted Pipeline as follows:</p>

<pre><code class="groovy">@Library('utils') import static org.foo.Utilities.*
node {
  mvn this, 'clean package'
}
</code></pre>

<h3>Reference</h3>

<ul>
<li><a href="https://jenkins.io/doc/book/pipeline/shared-libraries/">Accessing Steps section in Jenkins Doc</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins Plugin Development]]></title>
    <link href="http://tdongsi.github.io/blog/2017/11/29/jenkins-plugin-development/"/>
    <updated>2017-11-29T07:47:17-08:00</updated>
    <id>http://tdongsi.github.io/blog/2017/11/29/jenkins-plugin-development</id>
    <content type="html"><![CDATA[<p>How to create a Jenkins plugin.</p>

<!--more-->


<h3>Basic plugin</h3>

<p>Reference:</p>

<ul>
<li><a href="https://github.com/MarkEWaite/hello-world-plugin/tree/jenkins-world-2017">Tutorial</a></li>
<li><a href="https://www.youtube.com/watch?feature=player_embedded&amp;v=azyv183Ua6U">Video</a></li>
</ul>


<h3>Pipeline plugin</h3>

<p>Reference:</p>

<ul>
<li><a href="https://github.com/jglick/wfdev/tree/pipeline">Tutorial</a></li>
<li><a href="https://github.com/jglick/wfdev/blob/master/preso.pdf">Slides</a></li>
<li><a href="https://github.com/jenkinsci/pipeline-plugin/blob/master/DEVGUIDE.md">Developer&rsquo;s guide</a></li>
</ul>


<h3>Blue Ocean plugin</h3>

<pre><code class="plain Local development of Blue Ocean plugin"># this will build and run the plugin in local Jenkins
mvn install hpi:run
# this will recompile js &amp; less while editing
npm run bundle:watch
</code></pre>

<p><strong><em>Gotcha</em></strong>: extension changes won&rsquo;t update without a Jenkins restart.</p>
]]></content>
  </entry>
  
</feed>
