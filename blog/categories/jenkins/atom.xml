<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jenkins | Personal Programming Notes]]></title>
  <link href="http://tdongsi.github.io/blog/categories/jenkins/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/"/>
  <updated>2017-07-12T02:28:18-07:00</updated>
  <id>http://tdongsi.github.io/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Troubleshooting Groovy Code in Jenkinsfile]]></title>
    <link href="http://tdongsi.github.io/blog/2017/06/16/troubleshooting-groovy-scripts-in-jenkinsfile/"/>
    <updated>2017-06-16T23:52:44-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/06/16/troubleshooting-groovy-scripts-in-jenkinsfile</id>
    <content type="html"><![CDATA[<p>In this post, we look into some troubleshooting tips when <a href="/blog/2017/04/18/groovy-code-in-jenkins-pipeline/">using independent Groovy scripts in Jenkins pipeline</a> and how to work around those.</p>

<!--more-->


<h3>Cannot load a Groovy script in Declarative Pipeline</h3>

<p><strong>Problem</strong>: Loading Groovy methods from a file with <code>load</code> step does not work inside Declarative Pipeline step, as reported in <a href="https://issues.jenkins-ci.org/browse/JENKINS-43455">this issue</a>.</p>

<p><strong>Workaround</strong>: There are a few work-arounds. The most straight-forward one is to use <a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline"><code>script</code> step</a>.</p>

<pre><code class="groovy Loading Groovy script">    steps {
        checkout scm
        withCredentials([
            [$class: 'StringBinding', credentialsId: 'nexusUserName', variable: 'nexusUserName'],
            [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'nexusPassword']
        ]) {
            script {
                myScript = load 'jenkins/xml.groovy'
                String myFile = myScript.transformXml(settingsFile, env.nexusUserName, env.nexusPassword)
                sh "mvn -B -s ${myFile} clean compile"

                sh "rm ${myFile}"
            }
        }
    }
</code></pre>

<p> You can also define Groovy methods from inside the Jenkinsfile.</p>

<pre><code class="groovy Example Jenkinsfile">import groovy.xml.StreamingMarkupBuilder
import groovy.xml.XmlUtil

@NonCPS
def xmlTransform(txt, username, password) {

    def xmlRoot = new XmlSlurper(false, false).parseText(txt)
    echo 'Start tranforming XML'
    xmlRoot.servers.server.each { node -&gt;
       node.username = username
       node.password = password
    }

    // TRICKY: FileWriter does NOT work
    def outWriter = new StringWriter()
    XmlUtil.serialize( xmlRoot, outWriter )
    return outWriter.toString()
}

...

   steps {
        checkout scm
        withCredentials([
            [$class: 'StringBinding', credentialsId: 'nexusUserName', variable: 'nexusUserName'],
            [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'nexusPassword']
        ]) {
            script {
                myScript = load 'jenkins/xml.groovy'
                String myFile = xmlTransform(settingsFile, env.nexusUserName, env.nexusPassword)
                sh "mvn -B -s ${myFile} clean compile"

                sh "rm ${myFile}"
            }
        }
    }
</code></pre>

<p>For Declarative Pipeline, to reuse the code from a Groovy script, you must use Shared Libraries.
Shared Libraries are not specific to Declarative; they were released some time ago and were seen in Scripted Pipeline.
<a href="/blog/2017/03/17/jenkins-pipeline-shared-libraries/">This blog post</a> discusses an older mechanism for Shared Library.
For the newer mechanism of importing library, please check out <a href="https://jenkins.io/blog/2017/02/15/declarative-notifications/">this blog post</a>.
Due to Declarative Pipelineâ€™s lack of support for defining methods, Shared Libraries definitely take on a vital role for code-reuse in Jenkinsfile.</p>

<h3><code>File</code> reading and writing not supported</h3>

<p>Java/Grooy reading and writing using &ldquo;java.io.File&rdquo; class is not directly supported.</p>

<pre><code class="groovy Using File class does NOT work">def myFile = new File('/home/data/myfile.xml')
</code></pre>

<p>In fact, using that class in Jenkinsfile must go through &ldquo;In-Process Script Approval&rdquo; with this warning.</p>

<p><blockquote><p>new java.io.File java.lang.String Approving this signature may introduce a security vulnerability! You are advised to deny it.</p></blockquote></p>

<p>Even then, &ldquo;java.io.File&rdquo; will refer to <strong>files on the master</strong> (where Jenkins is running), not the current workspace on Jenkins slave (or slave container).
As a result, it will report the following error even though the file is present in filesystem (<a href="https://stackoverflow.com/questions/41739468/groovy-reports-that-a-file-doesnt-exists-when-it-really-is-present-in-the-syste">relevant Stackoverflow</a>) on slave:</p>

<pre><code class="plain">java.io.FileNotFoundException: /home/data/myfile.xml (No such file or directory)
    at java.io.FileInputStream.open0(Native Method)
</code></pre>

<p>That also means related class such as FileWriter will NOT work as expected.
It reports no error during execution but you will find no file since those files are created on Jenkins master.</p>

<p><strong>Workaround</strong>:</p>

<ul>
<li>For file reading, use <a href="https://jenkins.io/doc/pipeline/steps/workflow-basic-steps/#readfile-read-file-from-workspace"><code>readFile</code> step</a>.</li>
<li>For file writing, use <code>writeFile</code> step. However, Pipeline steps (such as <code>writeFile</code>) are NOT allowed in <code>@NonCPS</code> methods. For more complex file writing, you might want to export the file content as String and use the following code snippet:</li>
</ul>


<pre><code class="groovy Shell command">    String xmlFile = ...

    // TRICKY: FileWriter does NOT work in xmlTransform
    def mCommand = "cat &gt;${settingsFile} &lt;&lt;EOF"
    mCommand += "\n${xmlFile}\nEOF"
    sh mCommand
</code></pre>

<p>In the code snippet above, we construct a <a href="https://en.wikipedia.org/wiki/Here_document#Unix_shells"><em>here document</em>-formatted</a> command for writing multi-line string in <code>mCommand</code> before passing to <code>sh</code> step for executing.</p>

<pre><code class="plain heredoc example to explain mCommand">$ cat &gt;output.txt &lt;&lt;EOF
SELECT foo, bar FROM db
WHERE foo='baz'
More line from xmlFile
EOF

$ cat output.txt
SELECT foo, bar FROM db
WHERE foo='baz'
More line from xmlFile
</code></pre>

<h3>Serialization errors</h3>

<p>You often encounter this type of errors when using non-serialiable classes from Groovy/Java libraries.</p>

<pre><code class="plain Error in Jenkins log">java.io.NotSerializableException: org.codehaus.groovy.control.ErrorCollector
    at org.jboss.marshalling.river.RiverMarshaller.doWriteObject(RiverMarshaller.java:860)
</code></pre>

<pre><code class="plain Related error in Jenkins log">java.lang.UnsupportedOperationException: Calling public static java.lang.Iterable 
org.codehaus.groovy.runtime.DefaultGroovyMethods.each(java.lang.Iterable,groovy.lang.Closure) on a
CPS-transformed closure is not yet supported (JENKINS-26481); 
encapsulate in a @NonCPS method, or use Java-style loops
    at org.jenkinsci.plugins.workflow.cps.GroovyClassLoaderWhitelist.checkJenkins26481
    (GroovyClassLoaderWhitelist.java:90)
</code></pre>

<p>There is also some known <a href="https://issues.jenkins-ci.org/browse/JENKINS-35140">issue about JsonSlurper</a>.
These problems come from the fact that variables in Jenkins pipelines must be serializable.
Since pipeline must survive a Jenkins restart, the state of the running program is periodically saved to disk for possible resume later.
Any &ldquo;live&rdquo; objects such as a network connection is not serializble.</p>

<p><strong>Workaround</strong>:
Explicitly discard non-serializable objects or use <a href="https://support.cloudbees.com/hc/en-us/articles/230612967-Pipeline-The-pipeline-even-if-successful-ends-with-java-io-NotSerializableException">@NonCPS</a> methods.</p>

<p>Quoted from <a href="https://github.com/jenkinsci/workflow-cps-plugin/blob/master/README.md">here</a>: <code>@NonCPS</code> methods may safely use non-<code>Serializable</code> objects as local variables, though they should NOT accept nonserializable parameters or return or store nonserializable values.
You may NOT call regular (CPS-transformed) methods, or Pipeline steps, from a <code>@NonCPS</code> method, so they are best used for performing some calculations before passing a summary back to the main script.</p>

<h3>References</h3>

<ul>
<li><a href="https://jenkins.io/doc/book/pipeline/syntax/#declarative-pipeline">Declarative syntax</a></li>
<li><a href="https://jenkins.io/blog/2017/02/15/declarative-notifications/">Shared Libraries for Declarative Pipeline</a></li>
<li>Here document

<ul>
<li><a href="https://en.wikipedia.org/wiki/Here_document#Unix_shells">Theory</a></li>
<li><a href="https://stackoverflow.com/questions/2500436/how-does-cat-eof-work-in-bash">Common usage from Stackoverflow</a></li>
<li><a href="http://www.guguncube.com/2140/unix-set-a-multi-line-text-to-a-string-variable-or-file-in-bash">Heredoc with and without variable expansion</a></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sending Emails From Docker Containers]]></title>
    <link href="http://tdongsi.github.io/blog/2017/05/25/sending-emails-from-docker-containers/"/>
    <updated>2017-05-25T13:42:45-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/05/25/sending-emails-from-docker-containers</id>
    <content type="html"><![CDATA[<p>In this post, we looks into how to set up notification emails at the end of CI pipelines in a containerized Jenkins system.
First, we look into conventional Jenkins system (directly hosted) that has direct communication to the SMTP server.
After that, we will look into adjustments required for a containerized Jenkins system to run in the same environment.</p>

<!--more-->


<h3>Sending emails in standard Jenkins setup</h3>

<p>We first look at a typical Jenkins setup, where the Jenkins instance is installed directly on a host machine (VM or bare-metal) and has direct communication to the SMTP server.
For corporate network, you may have to use an SMTP relay server instead.
For those cases, you can configure SMTP communication by <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-postfix-as-a-send-only-smtp-server-on-ubuntu-14-04">setting up Postfix</a>.
Its typical settings is defined in <em>/etc/postfix/main.cf</em> file like this:</p>

<pre><code class="plain /etc/postfix/main.cf example"># See /usr/share/postfix/main.cf.bak for a commented, more complete version

myhostname = dev-worker-1.example.com
smtpd_banner = $myhostname ESMTP $mail_name
biff = no

# appending .domain is the MUA's job.
append_dot_mydomain = no

# Uncomment the next line to generate "delayed mail" warnings
#delay_warning_time = 4h

readme_directory = no

# TLS parameters
smtpd_tls_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
smtpd_tls_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
smtpd_use_tls=yes

# See /usr/share/doc/postfix/TLS_README.gz in the postfix-doc package for
# information on enabling SSL in the smtp client.


alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases
myorigin = dev-worker-1.example.com
mydestination = dev-worker-1.example.com, localhost.example.com, localhost
relayhost = smtprelay-prd.example.com
mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128
mailbox_size_limit = 0
recipient_delimiter = +
inet_interfaces = localhost
inet_protocols = all
</code></pre>

<p>We can test the setup by sending a test email with the following command:</p>

<pre><code class="plain Send a test email">[tdongsi@dev-worker-1 ~]# echo "Test localhost" | mailx -s Test tdongsi@example.com
send-mail: warning: inet_protocols: disabling IPv6 name/address support: Address family not supported by protocol
postdrop: warning: inet_protocols: disabling IPv6 name/address support: Address family not supported by protocol
</code></pre>

<p>After the <code>postfix</code> service is up, Jenkins can be configured to send email with <a href="https://wiki.jenkins-ci.org/display/JENKINS/Mailer">Mailer plugin</a>.
Mail server can be configured in <strong>Manage Jenkins</strong> page, <strong>E-mail Notification</strong> section.
Please visit <a href="http://www.nailedtothex.org/roller/kyle/entry/articles-jenkins-email">this post</a> for more detailed instructions and screenshots.
We can also test the configuration by sending test e-mail in the same <strong>E-mail Notification</strong> section.</p>

<h3>Sending email from container</h3>

<p>Many Jenkins-based CI systems have been containerized and deployed on Kubernetes cluster (in conjunction with <a href="https://wiki.jenkins-ci.org/display/JENKINS/Kubernetes+Plugin">Kubernetes plugin</a>).
For email notifications in such CI systems, one option is to reuse <code>postfix</code> service, which is usually configured and ready on the Kubernetes nodes, and expose it to the Docker containers.</p>

<p>There are two changes need to be made on Postfix to expose it to Docker containers on one host.</p>

<ol>
<li>Exposing Postfix to the docker network, that is, Postfix must be configured to bind to localhost as well as the docker network.</li>
<li>Accepting all incoming connections which come from any Docker containers.</li>
</ol>


<p>Docker bridge (<code>docker0</code>) acts a a bridge between your ethernet port and docker containers so that data can go back and forth.
We achieve the first requirement by adding the IP of <code>docker0</code> to <code>inet_iterfaces</code>.</p>

<pre><code class="plain ifconfig example output">[centos@dev-worker-1 ~]$ ifconfig
docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1472
        inet 172.22.91.1  netmask 255.255.255.0  broadcast 0.0.0.0
        ether 02:42:88:5f:24:28  txqueuelen 0  (Ethernet)
        RX packets 8624183  bytes 18891507332 (17.5 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 15891332  bytes 16911210191 (15.7 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

flannel0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1472
        inet 172.22.91.0  netmask 255.255.0.0  destination 172.22.91.0
        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 500  (UNSPEC)
        RX packets 10508237  bytes 7051646109 (6.5 GiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 15511583  bytes 18744591891 (17.4 GiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>

<p>For the second requirement, the whole docker network as well as localhost should be added to <code>mynetworks</code>.
In our kubernetes setup, the docker network should be <code>flannel0</code> and its subnet&rsquo;s CIDR notation is added to the <code>mynetworks</code> line:</p>

<pre><code class="plain Modified "/etc/postfix/main.cf""># See /usr/share/postfix/main.cf.bak for a commented, more complete version

myhostname = dev-worker-1.example.com
smtpd_banner = $myhostname ESMTP $mail_name
biff = no

# appending .domain is the MUA's job.
append_dot_mydomain = no

# Uncomment the next line to generate "delayed mail" warnings
#delay_warning_time = 4h

readme_directory = no

# TLS parameters
smtpd_tls_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
smtpd_tls_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
smtpd_use_tls=yes

# See /usr/share/doc/postfix/TLS_README.gz in the postfix-doc package for
# information on enabling SSL in the smtp client.

alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases
myorigin = dev-worker-1.example.com
mydestination = dev-worker-1.example.com, localhost.example.com, localhost
relayhost = smtprelay-prd.example.com
mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 172.22.0.0/16
mailbox_size_limit = 0
recipient_delimiter = +
inet_interfaces = localhost, 172.22.91.1
inet_protocols = all
</code></pre>

<p>Note the differences in <code>inet_interfaces</code> and <code>mynetworks</code> from the last section.
One can simply enter the Docker container/Kubernetes pod to verify such setup.
Note that application <code>mailx</code> maybe not available in a container since we tend to keep the containers light-weight.
Instead, prepare a <code>sendmail.txt</code> file (based on <a href="http://docs.blowb.org/setup-host/postfix.html">this</a>) with the following SMTP commands and use <code>nc</code> to send out the email as shown below.</p>

<pre><code class="plain Send test email from container">mymac:k8s tdongsi$ kubectl --kubeconfig kubeconfig --namespace jenkins exec -it jenkins-8hgsn -- bash -il

jenkins@jenkins-8hgsn:~/test$ cat sendmail.txt
HELO x
MAIL FROM: test@example.com
RCPT TO: tdongsi@example.com
DATA
From: test@example.com
To: $YOUR_EMAIL
Subject: This is a test

The test is successful

.
quit

jenkins@jenkins-8hgsn:~/test$ nc 172.22.91.1 25 &lt;sendmail.txt
220 dev-worker-1.eng.sfdc.net ESMTP Postfix
250 dev-worker-1.eng.sfdc.net
250 2.1.0 Ok
250 2.1.5 Ok
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
250 2.0.0 Ok: queued as 1EF9E60C34
221 2.0.0 Bye
</code></pre>

<p>For containerized Jenkins system, mail server can also be configured in same <strong>Manage Jenkins</strong> page, <strong>E-mail Notification</strong> section.
The only difference is the IP/hostname provided to <strong>SMTP server</strong> option.
Instead of providing the known SMTP server&rsquo;s IP and host, one should use the IP of <code>docker0</code>, as explained above.
In the case of many nodes in Kubernetes cluster with different <code>docker0</code> IP, the Docker container of Jenkins master should reside only on one host and <code>docker0</code>&rsquo;s IP on that host should be used.</p>

<h3>References</h3>

<ul>
<li><a href="http://www.nailedtothex.org/roller/kyle/entry/articles-jenkins-email">Standard email setup in Jenkins</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-postfix-as-a-send-only-smtp-server-on-ubuntu-14-04">Setup Postfix</a></li>
<li><a href="http://docs.blowb.org/setup-host/postfix.html">Configure Postfix for Docker Containers</a></li>
<li><a href="http://satishgandham.com/2016/12/sending-email-from-docker-through-postfix-installed-on-the-host/">More on Postfix for Docker Containers</a></li>
</ul>


<pre><code class="plain postfix version used in this post">[tdongsi@dev-worker-1 ~]$ postconf -v | grep mail_version
mail_version = 2.10.1
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven and Gradle Builds in Jenkinsfile]]></title>
    <link href="http://tdongsi.github.io/blog/2017/05/20/gradle-settings-in-jenkinsfile/"/>
    <updated>2017-05-20T23:27:08-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/05/20/gradle-settings-in-jenkinsfile</id>
    <content type="html"><![CDATA[<p>In this post, we will look into how to securely authenticate with Nexus for Maven and Gradle builds in Jenkins pipelines.
Nexus username and password should NOT be stored in plain text on Jenkins slaves or Docker images.
Instead, those credentials should be passed into Jenkins pipeline using <code>withCredentials</code> step.</p>

<!--more-->


<h3>Maven</h3>

<p>Maven builds in corporates usually use private repositories on Nexus, instead of public ones in Maven Central Repository.
To do that, we usually configure Maven to check Nexus instead of the default, built-in connection to Maven Central.
These configurations is stored in <em>~/.m2/settings.xml</em> file.</p>

<p>For authentication with Nexus and for deployment, we must <a href="https://books.sonatype.com/nexus-book/reference/_adding_credentials_to_your_maven_settings.html">provide credentials accordingly</a>.
We usually add the credentials into our Maven Settings in <em>settings.xml</em> file.</p>

<pre><code class="xml Example Credentials in settings.xml">&lt;settings&gt;
  &lt;servers&gt;
    &lt;server&gt;
      &lt;id&gt;nexus&lt;/id&gt;
      &lt;username&gt;deployment&lt;/username&gt;
      &lt;password&gt;deployment123&lt;/password&gt;
    &lt;/server&gt;
  &lt;/servers&gt;
&lt;/settings&gt;
</code></pre>

<p>However, for automated build and deployment in Jenkins pipelines, it is not safe to store credentials in plain text files.
Instead, one should store Nexus credentials as <a href="https://wiki.jenkins-ci.org/display/JENKINS/Credentials+Plugin">secrets in Jenkins</a> and pass them into Jenkinsfile using their IDs (<code>credentialsId</code>).
See <a href="https://support.cloudbees.com/hc/en-us/articles/203802500-Injecting-Secrets-into-Jenkins-Build-Jobs">this article</a> for the full picture of related plugins used for storing and passing secrets in Jenkins.</p>

<pre><code class="groovy Nexus authentication for Maven in Jenkinsfile.">  withCredentials([
    [$class: 'StringBinding', credentialsId: 'nexusUsername', variable: 'nexusUsername'],
    [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'nexusPassword']
  ]) {
    withEnv([
      'nexusPublic=https://nexus.example.com/nexus/content/groups/public/'
    ]) {
      def xmlTemplate = readFile templateFile
      String xmlFile = transformXml(xmlTemplate, env.nexusUsername, env.nexusPassword)

      String tempFile = 'temp.xml'
      writeFile file: tempFile, text: xmlFile

      sh "mvn -B clean build -s ${tempFile}"
    }
  }
</code></pre>

<p>The <a href="https://jenkins.io/doc/pipeline/steps/credentials-binding/">step <code>withCredentials</code></a> will not only provide a secure way of injecting secrets (e.g., Nexus credentials) into Jenkins pipeline, but also scrub away such sensitive information if we happen to print them out in log files.
<code>transformXml</code> is my Groovy function that generates the <code>settings.xml</code> from the redacted Maven settings.xml template (no credentials) and the provided Nexus credentials.</p>

<h4>Maven 3.0</h4>

<p>Since <strong>Maven 3.0</strong>, the above problem is made much easier since environment variables can be referred inside <code>settings.xml</code> file by using special expression <code>${env.VAR_NAME}</code>, based on <a href="https://maven.apache.org/settings.html">this doc</a>.
Nexus authentication for Maven 3.0 in Jenkins pipeline can be done as follows:</p>

<pre><code class="xml settings.xml in Maven 3.0">&lt;settings&gt;
  &lt;servers&gt;
    &lt;server&gt;
      &lt;id&gt;nexus&lt;/id&gt;
      &lt;username&gt;${env.MVN_SETTINGS_nexusUsername}&lt;/username&gt;
      &lt;password&gt;${env.MVN_SETTINGS_nexusPassword}&lt;/password&gt;
    &lt;/server&gt;
  &lt;/servers&gt;
&lt;/settings&gt;
</code></pre>

<pre><code class="groovy Passing Nexus credentials for Maven 3.0 in Jenkinsfile">  withCredentials([
    [$class: 'StringBinding', credentialsId: 'nexusUsername', variable: 'MVN_SETTINGS_nexusUsername'],
    [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'MVN_SETTINGS_nexusPassword']
  ]) {
    withEnv([
      'nexusPublic=https://nexus.example.com/nexus/content/groups/public/'
    ]) {
      sh 'mvn -s settings.xml clean build'
    }
  }
</code></pre>

<p>However, note that it is still tricky even in Maven 3.0 since this is not always applicable, as noted in <a href="https://maven.apache.org/settings.html">the same doc</a>.</p>

<p><blockquote><p>Note that properties defined in profiles within the settings.xml cannot be used for interpolation.</p></blockquote></p>

<h3>Gradle</h3>

<p>In Gradle, Nexus authentication can be specified in both <code>build.gradle</code> and <code>gradle.properties</code> file, where <code>build.gradle</code> should be checked into VCS (e.g., git) while <code>gradle.properties</code> contains sensitive credentials information.</p>

<pre><code class="groovy Example build.gradle">    repositories {
        maven {
            credentials {
                username nexusUsername
                password nexusPassword
            }
            url { nexusPublic }
        }
    }
</code></pre>

<pre><code class="properties Example gradle.properties">nexusUsername=myUsername
nexusPassword=password123
nexusPublic=https://nexus.example.com/nexus/content/groups/public/
</code></pre>

<p>The default location of the <code>gradle.properties</code> file is <code>~/.gradle</code>.
This is due to the environment variable <code>GRADLE_USER_HOME</code> usually set to <code>~/.gradle</code>.
For custom location of <code>gradle.properties</code> (i.e., other than <code>~/.gradle</code>), ensure that the variable <code>GRADLE_USER_HOME</code> is set accordingly.</p>

<p>However, similar to Maven, for Jenkins pipeline automation, it is not safe to store credentials in plain text file <code>gradle.properties</code>, no matter how &ldquo;hidden&rdquo; its location is.
For that purpose, you should use the following Groovy code:</p>

<pre><code class="groovy Nexus authentication for Gradle in Jenkinsfile.">  withCredentials([
    [$class: 'StringBinding', credentialsId: 'nexusUsername', variable: 'ORG_GRADLE_PROJECT_nexusUsername'],
    [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'ORG_GRADLE_PROJECT_nexusPassword']
  ]) {
    withEnv([
      'ORG_GRADLE_PROJECT_nexusPublic=https://nexus.example.com/nexus/content/groups/public/',
      'ORG_GRADLE_PROJECT_nexusReleases=https://nexus.example.com/nexus/content/repositories/releases',
      'ORG_GRADLE_PROJECT_nexusSnapshots=https://nexus.example.com/nexus/content/repositories/snapshots'
    ]) {
      sh './gradlew jenkinsBuild'
    }
  }
</code></pre>

<p>Note that, in Gradle, the solution is much simpler because Gradle respects properies set through environment variales.
Based on <a href="https://docs.gradle.org/current/userguide/build_environment.html">its doc</a>, if the environment variable name looks like <strong><em>ORG_GRADLE_PROJECT_prop=somevalue</em></strong>, then Gradle will set a <code>prop</code> property on your project object, with the value of <code>somevalue</code>.
Therefore, in <code>withCredentials</code> step, we specifically bind the secrets <code>nexusUsername</code> and <code>nexusPassword</code> to the environment variables <em>ORG_GRADLE_PROJECT_nexusUsername</em> and <em>ORG_GRADLE_PROJECT_nexusPassword</em> and not some arbitrary variable names.
These environment variables should match the ones used in <code>builde.gradle</code> and, in the following Closure, we simply call the standard Gradle wrapper command <code>./gradlew &lt;target&gt;</code>.
Compared with Maven solution in the last section, there is no intermediate step to generate <code>settings.xml</code> based on the provided secrets.</p>

<h3>More Tips</h3>

<p>If Maven/Gradle build is used in multiple repositories across organization, it is recommended to move the above Groovy code into shared Jenkins library, as shown in <a href="/blog/2017/03/17/jenkins-pipeline-shared-libraries/">last post</a>.
For example, the Gradle builds can be simplified by defining <code>useNexus</code> step (see <a href="https://jenkins.io/doc/book/pipeline/shared-libraries/#defining-steps">here</a>) and adding it into the <a href="/blog/2017/03/17/jenkins-pipeline-shared-libraries/">shared library <em>workflow-lib</em></a>.</p>

<pre><code class="groovy vars/useNexus.groovy">def call(Closure body) {
  withCredentials([
    [$class: 'StringBinding', credentialsId: 'nexusUsername', variable: 'ORG_GRADLE_PROJECT_nexusUsername'],
    [$class: 'StringBinding', credentialsId: 'nexusPassword', variable: 'ORG_GRADLE_PROJECT_nexusPassword']
  ]) {
    withEnv([
      'ORG_GRADLE_PROJECT_nexusPublic=https://nexus.example.com/nexus/content/groups/public/',
      'ORG_GRADLE_PROJECT_nexusReleases=https://nexus.example.com/nexus/content/repositories/releases',
      'ORG_GRADLE_PROJECT_nexusSnapshots=https://nexus.example.com/nexus/content/repositories/snapshots'
    ]) {
      body()
    }
  }
}
</code></pre>

<p>After that, all the Gradle builds with Nexus authentication in Jenkinsfile will now be reduced to simply this:</p>

<pre><code class="groovy Simplified Nexus authentication for Gradle in Jenkinsfile.">useNexus {
  sh './gradlew jenkinsBuild'
}
</code></pre>

<p>As shown above, it will reduce lots of redundant codes for Gradle builds, repeated again and again in Jenkinsfiles across multiple repositories in an organizaiton.</p>

<h3>References</h3>

<ul>
<li><a href="https://support.cloudbees.com/hc/en-us/articles/203802500-Injecting-Secrets-into-Jenkins-Build-Jobs">Secrets in Jenkins build jobs</a></li>
<li><a href="https://docs.gradle.org/current/userguide/build_environment.html">Gradle build environment</a></li>
<li><a href="https://stackoverflow.com/questions/12749225/where-to-put-gradle-configuration-i-e-credentials-that-should-not-be-committe">Stackoverflow dicussion</a>: for older versions of Gradle.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Troubleshooting Docker-out-of-Docker]]></title>
    <link href="http://tdongsi.github.io/blog/2017/04/26/troubleshooting-docker-out-of-docker/"/>
    <updated>2017-04-26T16:24:24-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/04/26/troubleshooting-docker-out-of-docker</id>
    <content type="html"><![CDATA[<p>In this blog post, we are using <a href="/blog/2017/04/23/docker-out-of-docker/">&ldquo;Docker out of Docker&rdquo; approach</a> to build Docker images in our containerized Jenkins slaves.
We look into a problem usually encountered in that approach, especially when reusing a Docker image for another Kubernetes cluster.</p>

<!--more-->


<h3>Problem description</h3>

<p>We got the following error when running Docker inside a Jenkins slave container.</p>

<pre><code class="plain Error message when running Docker">+ docker images
Cannot connect to the Docker daemon. Is the docker daemon running on this host?
</code></pre>

<h3>Discussion</h3>

<p>In summary, for <a href="/blog/2017/04/23/docker-out-of-docker/">&ldquo;Docker out of Docker&rdquo; approach</a>, the basic requirements to enable building Docker images in a containerized Jenkins slave is:</p>

<ol>
<li>You&rsquo;ll need to mount &ldquo;/var/run/docker.sock&rdquo; as a volume at &ldquo;/var/run/docker.sock&rdquo;.</li>
<li>Having <code>docker</code> CLI installed in the containerized Jenkins slave.</li>
<li>Make sure &ldquo;/var/run/docker.sock&rdquo; has the right permission inside the Jenkins slave container: readable for the current user (e.g., user <code>jenkins</code>) or in &ldquo;docker&rdquo; group.</li>
</ol>


<p>The direct cause of the above error message &ldquo;Cannot connect to the Docker daemon&rdquo; is that the socket &ldquo;/var/run/docker.sock&rdquo; to <code>docker</code> daemon on that Jenkins slave does not have the right permission for the current user (<code>jenkins</code> in the example).
By convention, the read permission to that Unix domain socket &ldquo;/var/run/docker.sock&rdquo; is given to <code>root</code> user or users in <code>docker</code> group.
The following commands verify that it is not:</p>

<pre><code class="plain Show GID of docker group">+ ls -l /var/run/docker.sock

srw-rw----. 1 root 992 0 Mar 14 00:57 /var/run/docker.sock
+ cat /etc/group
...
docker:x:999:jenkins
</code></pre>

<p>The expected output of the above <code>ls</code> command is as follows:</p>

<pre><code class="plain Expected output">+ ls -l /var/run/docker.sock
srw-rw----. 1 root docker 0 Mar 14 00:57 /var/run/docker.sock
</code></pre>

<p>The root cause of the problem is that the Docker image of Jenkins slave is built inside another Kubernetes cluster (see example Dockerfile below).
The group <code>docker</code> happens to have the group ID 999 on that Kubernetes cluster.</p>

<pre><code class="plain Dockerfile for installing Docker CLI in Jenkins slave http://stackoverflow.com/questions/31466812/access-docker-sock-from-inside-a-container">FROM jenkins

USER root
ENV DEBIAN_FRONTEND=noninteractive
ENV HOME /home/jenkins
ENV DOCKER_VERSION=1.9.1-0~trusty

RUN apt-get update \
  &amp;&amp; apt-get install -y docker-engine=$DOCKER_VERSION \
  &amp;&amp; rm -rf /var/lib/apt/lists/*

RUN usermod -a -G docker jenkins
</code></pre>

<p>For illustration, the Docker installation steps in Ubuntu are similar:</p>

<pre><code class="plain Installing Docker CLI https://docs.docker.com/engine/installation/linux/linux-postinstall/"># Install from Web
sudo curl -sSL https://get.docker.com/ | sh
sudo usermod -aG docker jenkins

# Install from apt
sudo apt-get update
sudo apt-get install -y docker-engine
sudo usermod -aG docker jenkins
</code></pre>

<p>The last step <code>usermod</code> comes from Docker documentation itself: &ldquo;If you would like to use Docker as a non-root user, you should now consider adding your user to the "docker&rdquo; group".</p>

<h3>Resolving problem</h3>

<p>To resolve the problem, simply entering the Docker image, update its <code>/etc/group</code> file with the correct GID for <code>docker</code> group.
In the example above, the line &ldquo;docker:x:999:jenkins&rdquo; should be updated to &ldquo;docker:x:992:jenkins&rdquo; to make it work.
It&rsquo;s recommended to run <code>docker commit</code> to save the modified container as a new Docker image and push it to Docker registry (similar process in <a href="http://localhost:4000/blog/2017/01/25/docker-root-user-in-a-pod/">this post</a>).</p>

<h3>References</h3>

<ul>
<li><a href="https://docs.docker.com/engine/reference/commandline/dockerd/">dockerd</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker-in-Docker vs Docker-out-of-Docker]]></title>
    <link href="http://tdongsi.github.io/blog/2017/04/23/docker-out-of-docker/"/>
    <updated>2017-04-23T10:42:04-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/04/23/docker-out-of-docker</id>
    <content type="html"><![CDATA[<p>In this post, we look into two different approaches to solving the problem of building/pushing Docker images from a containerized Jenkins system.
From that understanding, we will discuss the pros and cons of each approach in production Continuous Integration (CI) systems and how one should be used in practice.</p>

<!--more-->


<h3>Docker-in-Docker &amp; Docker-out-of-Docker</h3>

<p>Jenkins as a CI system has been increasingly containerized and ran as a Docker container in production.
An example setup is to run Jenkins on top of a Kubernetes cluster with Jenkins slaves are created on demand as containers, using <a href="https://wiki.jenkins-ci.org/display/JENKINS/Kubernetes+Plugin">Kubernetes plugin</a>.
The problem in this post arises from how to build/run/push the Docker images insides a Jenkins system that run as a Docker container itself.</p>

<p>&ldquo;Docker-in-Docker&rdquo; refers to the approach of installing and running another Docker engine (daemon) inside Docker containers.
Since Docker 0.6, a &ldquo;privileged&rdquo; option is added to allow running containers in a special mode with almost all capabilities of the host machine, including kernel features and devices acccess.
As a consequence, Docker engine, as a privileged application, can run inside a Docker container itself.</p>

<p>&ldquo;Docker-in-Docker&rdquo; is first discussed by Jerome Petazzoni in <a href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/">this blog post</a> with example codes.
However, in <a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">another following blog post</a>, Jerome cautioned against using his &ldquo;dind&rdquo; approach in containerized Jenkins.
He pointed out potential problems with his &ldquo;Docker-in-Docker&rdquo; approach and how to avoid those by simply bind-mounting the Docker socket into the Jenkins container.
The approach of bind-mounting the Docker socket is later referred as &ldquo;Docker-out-of-Docker&rdquo; approach.</p>

<h3>Which one should we use?</h3>

<p>As spelled out clearly by &ldquo;Docker-in-Docker&rdquo; creator Jerome Petazzoni himself, we should not use Docker-in-Docker, especially in containerized Jenkins systems.
Potential problems include 1) security profile of inner Docker will conflict with one of outer Docker 2) Incompatible file systems (e.g. AUFS inside Docker container).</p>

<p>Instead of trying to run Docker engine inside containers, it is advised to just expose the Docker socket to those containers.
This can be done by bind-mounting with the <code>-v</code> flag:</p>

<pre><code class="plain Docker out of Docker">docker run -v /var/run/docker.sock:/var/run/docker.sock ...
</code></pre>

<p>By using the above command, we can access the Docker daemon (running on the host machine) from inside the Docker container, and able to start/build/push containers.
The containers that are started inside the Docker container above are effectively &ldquo;sibling&rdquo; containers instead of &ldquo;child&rdquo; containers since the outer and inner containers are all running on the same host machine.
However, it is important to note that this feels like &ldquo;Docker-in-Docker&rdquo; but without any tricky problems associated with this.
And for the purpose of building/running/pushing Docker images in containerized Jenkins systems, this &ldquo;Docker-out-of-Docker&rdquo; is exactly all we need.</p>

<h3>Further discussion</h3>

<p>The potential issues of &ldquo;Docker-in-Docker&rdquo; is extensively discussed by Jerome Petazzoni in his blog post.
However, what&rsquo;s not mentioned is any potential problem of &ldquo;Docker-out-of-Docker&rdquo; approach.</p>

<p>In my opinion, one potential issue of &ldquo;Docker-out-of-Docker&rdquo; approach is one can access the outer Docker container from the inner container through &ldquo;/var/run/docker.sock&rdquo;.
In the context of containerized Jenkins system, the outer Docker container is usually Jenkins master with sensitive information.
The inside Docker containers are usually Jenkins slaves that are subject to running all kinds of code which might be malicious.
This means that a containerized Jenkins system can be easily compromised if there is no limit on what&rsquo;s running in Jenkins slaves.</p>

<p>It should be noted that, despite of problems listed by Jerome, &ldquo;Docker-in-Docker&rdquo; approach is still a possible choice *IF* you know what you are doing.
Conflict of security profiles can be resolved with the right, careful setup.
There are work-arounds for incompatible file systems between the containers.
With the right setup, &ldquo;Docker-in-Docker&rdquo; can provide essentially free build isolation and security, which is a must for many, especially in corporates.
However, the ever-present disadvantage of this apporach is long build time for large Docker images since Docker image cache has to be re-populated every run.
As noted by Jerome, this cache is designed for exclusive access by one single Docker daemon at once.
Trying to link this cache in each container to some common, pre-populated Docker image cache will lead to corrupt image data.</p>

<h3>References</h3>

<ul>
<li><a href="https://blog.docker.com/2013/09/docker-can-now-run-within-docker/">Docker-in-Docker</a></li>
<li><a href="https://github.com/jpetazzo/dind">dind</a></li>
<li><a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">Docker-out-of-Docker</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
