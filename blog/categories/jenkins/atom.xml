<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jenkins | Personal Programming Notes]]></title>
  <link href="http://tdongsi.github.io/blog/categories/jenkins/atom.xml" rel="self"/>
  <link href="http://tdongsi.github.io/"/>
  <updated>2018-02-01T23:59:50-08:00</updated>
  <id>http://tdongsi.github.io/</id>
  <author>
    <name><![CDATA[Cuong Dong-Si]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Groovy Hook Script and Jenkins Configuration as Code]]></title>
    <link href="http://tdongsi.github.io/blog/2017/12/30/groovy-hook-script-and-jenkins-configuration-as-code/"/>
    <updated>2017-12-30T21:02:48-08:00</updated>
    <id>http://tdongsi.github.io/blog/2017/12/30/groovy-hook-script-and-jenkins-configuration-as-code</id>
    <content type="html"><![CDATA[<p>This post discusses <a href="https://wiki.jenkins.io/display/JENKINS/Groovy+Hook+Script">Groovy Hook Scripts</a> and how to use them for full configuration-as-code in Jenkins with Docker, Pipeline.
This can help us to set up local environment for developing Jenkins Pipeline libraries and to evaluate various Jenkins features.</p>

<!--more-->


<h3>Groovy Hook Scripts</h3>

<p>These scripts are written in Groovy, and get executed inside the same JVM as Jenkins, allowing full access to the domain model of Jenkins.
For given hook <code>HOOK</code>, the following locations are searched:</p>

<pre><code>WEB-INF/HOOK.groovy in jenkins.war
WEB-INF/HOOK.groovy.d/*.groovy in the lexical order in jenkins.war
$JENKINS_HOME/HOOK.groovy
$JENKINS_HOME/HOOK.groovy.d/*.groovy in the lexical order
</code></pre>

<p>The <code>init</code> is the most commonly used hook.</p>

<ul>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Groovy+Hook+Script">Groovy Hook Script</a></li>
</ul>


<h3>Authorization</h3>

<p>This section shows how to enable different authorization strategies in Groovy code.</p>

<pre><code class="groovy "Logged-in users can do anything"">import jenkins.model.*
def instance = Jenkins.getInstance()

import hudson.security.*
def realm = new HudsonPrivateSecurityRealm(false)
instance.setSecurityRealm(realm)

def strategy = new hudson.security.FullControlOnceLoggedInAuthorizationStrategy()
strategy.setAllowAnonymousRead(false)
instance.setAuthorizationStrategy(strategy)

instance.save()
</code></pre>

<p>Matrix-based authorization: Gives all authenticated users admin access:</p>

<pre><code class="groovy Matrix-based authorization">import jenkins.model.*
def instance = Jenkins.getInstance()

import hudson.security.*
def realm = new HudsonPrivateSecurityRealm(false)
instance.setSecurityRealm(realm)

def strategy = new hudson.security.GlobalMatrixAuthorizationStrategy()
strategy.add(Jenkins.ADMINISTER, 'authenticated')
instance.setAuthorizationStrategy(strategy)

instance.save()
</code></pre>

<p>For importing GlobalMatrixAuthorizationStrategy class, make sure that <a href="https://wiki.jenkins.io/display/JENKINS/Matrix+Authorization+Strategy+Plugin"><code>matrix-auth</code> plugin</a> is installed.
For full list of standard permissions in the matrix, see <a href="https://gist.github.com/jnbnyc/c6213d3d12c8f848a385">this code snippet</a>.
Note that the matrix can be different if different plugins are installed.
For example, the &ldquo;Replay&rdquo; permission for Runs is not simply <code>hudson.model.Run.REPLAY</code> since there is no such static constant.
Such permission is only available after <a href="https://github.com/jenkinsci/workflow-cps-plugin">Workflow CPS plugin</a> is installed.
Therefore, we can only set &ldquo;Replay&rdquo; permission for Runs with the following:</p>

<pre><code class="groovy">strategy.add(org.jenkinsci.plugins.workflow.cps.replay.ReplayAction.REPLAY,USER)
</code></pre>

<p><strong>References</strong></p>

<ul>
<li><a href="https://gist.github.com/jnbnyc/c6213d3d12c8f848a385">Matrix-based Authorizaiton</a></li>
<li><a href="https://github.com/oleg-nenashev/demo-jenkins-config-as-code">Jenkins config as code</a></li>
</ul>


<h3>Basic Jenkins security</h3>

<p>In addition to enable authorization strategy, we should also set some basic configurations for hardening Jenkins.
Those includes various options that you see in Jenkins UI when going to Manage Jenkins > Configure Global Security.</p>

<ul>
<li><a href="https://support.cloudbees.com/hc/en-us/articles/234709648-Disable-Jenkins-CLI">Disable Jenkins CLI</a></li>
<li>Limit Jenkins agent protocols.</li>
<li>&ldquo;Enable Slave -> Master Access Control&rdquo;</li>
<li>&ldquo;Prevent Cross Site Request Forgery exploits&rdquo;</li>
</ul>


<pre><code class="groovy Basic Jenkins security">import hudson.security.csrf.DefaultCrumbIssuer
import jenkins.model.Jenkins
import jenkins.model.JenkinsLocationConfiguration
import jenkins.security.s2m.AdminWhitelistRule
import org.kohsuke.stapler.StaplerProxy
import hudson.tasks.Mailer

println("--- Configuring Remoting (JNLP4 only, no Remoting CLI)")
Jenkins.instance.getDescriptor("jenkins.CLI").get().setEnabled(false)
Jenkins.instance.agentProtocols = new HashSet&lt;String&gt;(["JNLP4-connect"])

println("--- Enable Slave -&gt; Master Access Control")
Jenkins.instance.getExtensionList(StaplerProxy.class)
    .get(AdminWhitelistRule.class)
    .masterKillSwitch = false

println("--- Checking the CSRF protection")
if (Jenkins.instance.crumbIssuer == null) {
    println "CSRF protection is disabled, Enabling the default Crumb Issuer"
    Jenkins.instance.crumbIssuer = new DefaultCrumbIssuer(true)
}

println("--- Configuring Quiet Period")
// We do not wait for anything
Jenkins.instance.quietPeriod = 0
Jenkins.instance.save()

println("--- Configuring Email global settings")
JenkinsLocationConfiguration.get().adminAddress = "admin@non.existent.email"
Mailer.descriptor().defaultSuffix = "@non.existent.email"
</code></pre>

<p>Some are not working for versions before 2.46, according to <a href="https://support.cloudbees.com/hc/en-us/articles/234709648-Disable-Jenkins-CLI">this</a>.
For disabling Jenkins CLI, you can simply add the java argument <code>-Djenkins.CLI.disabled=true</code> on Jenkins startup.</p>

<p><strong>References</strong></p>

<ul>
<li><a href="https://support.cloudbees.com/hc/en-us/articles/234709648-Disable-Jenkins-CLI">Disable Jenkins CLI: different versions</a></li>
<li><a href="https://wiki.jenkins.io/display/JENKINS/Slave+To+Master+Access+Control">Slave to Master Access Control</a></li>
</ul>


<h3>Create Jobs and Items</h3>

<pre><code class="groovy Create "Pipeline script from SCM" job">import hudson.plugins.git.*;

def scm = new GitSCM("git@github.com:dermeister0/Tests.git")
scm.branches = [new BranchSpec("*/develop")];

def flowDefinition = new org.jenkinsci.plugins.workflow.cps.CpsScmFlowDefinition(scm, "Jenkinsfile")

def parent = Jenkins.instance
def job = new org.jenkinsci.plugins.workflow.job.WorkflowJob(parent, "New Job")
job.definition = flowDefinition
</code></pre>

<ul>
<li><a href="https://stackoverflow.com/questions/16963309/how-create-and-configure-a-new-jenkins-job-using-groovy">Stackoverflow thread</a></li>
<li><a href="https://github.com/linagora/james-jenkins/blob/master/create-dsl-job.groovy">More example</a></li>
</ul>


<h3>Create credentials</h3>

<p>TODO</p>

<ul>
<li><a href="https://support.cloudbees.com/hc/en-us/articles/217708168-create-credentials-from-groovy">CloudBees tutorial</a></li>
</ul>


<h3>Notifications</h3>

<pre><code class="groovy Configure Slack">import jenkins.model.*
def instance = Jenkins.getInstance()

// configure slack
def slack = Jenkins.instance.getExtensionList(
  jenkins.plugins.slack.SlackNotifier.DescriptorImpl.class
)[0]
def params = [
  slackTeamDomain: "domain",
  slackToken: "token",
  slackRoom: "",
  slackBuildServerUrl: "$JENKINS_URL",
  slackSendAs: ""
]
def req = [
  getParameter: { name -&gt; params[name] }
] as org.kohsuke.stapler.StaplerRequest
slack.configure(req, null)
slack.save()
</code></pre>

<pre><code class="groovy Global email settings">import jenkins.model.*
def instance = Jenkins.getInstance()

// set email
def location_config = JenkinsLocationConfiguration.get()
location_config.setAdminAddress("jenkins@skynet.net")
</code></pre>

<h3>Tools</h3>

<p>JDKs and Maven can be setup with the following (<a href="https://github.com/oleg-nenashev/demo-jenkins-config-as-code/blob/master/init_scripts/src/main/groovy/scripts/Tools.groovy">reference</a>):</p>

<pre><code class="groovy Setup JDKs and Maven">import jenkins.model.Jenkins
import hudson.model.JDK
import hudson.tasks.Maven.MavenInstallation;
import hudson.tasks.Maven
import hudson.tools.InstallSourceProperty

println("--- Setup tool installations")
// By default we offer no JDK7, Nodes should override
JDK jdk7 = new JDK("jdk7", "/non/existent/JVM")
// Java 8 should be a default Java, because we require it for Jenkins 2.60.1+
JDK jdk8 = new JDK("jdk8", "")
Jenkins.instance.getDescriptorByType(JDK.DescriptorImpl.class).setInstallations(jdk7, jdk8)

InstallSourceProperty p = new InstallSourceProperty([new Maven.MavenInstaller("3.5.0")])
MavenInstallation mvn = new MavenInstallation("mvn", null, [p])
Jenkins.instance.getDescriptorByType(Maven.DescriptorImpl.class).setInstallations(mvn)

// Configure global maven options
def maven = Jenkins.instance.getExtensionList(
  hudson.maven.MavenModuleSet.DescriptorImpl.class
)[0]
maven.setGlobalMavenOpts("-Dmaven.test.failure.ignore=false")
maven.save()
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[`src` Folder in Jenkins Shared Library]]></title>
    <link href="http://tdongsi.github.io/blog/2017/12/26/class-in-jenkins-shared-library/"/>
    <updated>2017-12-26T11:18:09-08:00</updated>
    <id>http://tdongsi.github.io/blog/2017/12/26/class-in-jenkins-shared-library</id>
    <content type="html"><![CDATA[<p>This post reviews best practices when we implement Groovy classes and/or static Groovy methods, in <code>src</code> folder as opposed to <code>vars</code> folder, for Jenkins Shared Library.</p>

<!--more-->


<h3>Examples of shared libraries in <code>src</code> folder</h3>

<p>All Groovy files in Jenkins shared library for pipelines have to follow this directory structure:</p>

<pre><code class="plain Directory structure of a Shared Library repository">(root)
+- src                     # Groovy source files
|   +- org
|       +- foo
|           +- Bar.groovy  # for org.foo.Bar class
+- vars
|   +- foo.groovy          # for global 'foo' variable
|   +- foo.txt             # help for 'foo' variable
+- resources               # resource files (external libraries only)
|   +- org
|       +- foo
|           +- bar.json    # static helper data for org.foo.Bar
</code></pre>

<p><code>src</code> folder is intended to set up with <code>groovy</code> files in the standard directory structure, such as &ldquo;src/org/foo/bar.groovy&rdquo;.
It will be added to the class path when the Jenkins pipelines are executed.</p>

<p>Any custom function in a Jenkins shared library has to eventually use basic Pipeline steps such as <code>sh</code> or <code>git</code>.
However, Groovy classes in shared Jenkins library cannot directly call those basic steps.
They can however implement methods, outside of the scope of an enclosing class, which in turn invoke Pipeline steps, for example:</p>

<pre><code class="groovy Example 1">// src/org/demo/buildUtils.groovy
package org.demo

def checkOutFrom(repo) {
  git url: "git@github.com:jenkinsci/${repo}"
}
</code></pre>

<p>Which is stored implicitly in library and can then be invoked from a Scripted Pipeline:</p>

<pre><code class="groovy Example 1 (continued)">def myUtils = new org.demo.buildUtils()
myUtils.checkOutFrom(repo)
</code></pre>

<p>This approach has limitations; for example, it prevents the declaration of a superclass.</p>

<p>In the following example, we create an enclosing class that would facilitate things like defining a superclass.
In that case, to access standard DSL steps such as <code>sh</code> or <code>git</code>, we can explicitly pass special global variables <code>env</code> and <code>steps</code> into a constructor or a method of the class.
Global object <code>env</code> contains all current environment variables while <code>steps</code> contains all standard pipeline steps.
Note that the class must also implement Serializable interface to support saving the state if the pipeline is stopped or resumed.</p>

<pre><code class="groovy Example 2">package org.demo
class Utilities implements Serializable {
  def env
  def steps
  Utilities(env, steps) {
    this.env = env
    this.steps = steps
  }

  def mvn(args) {
    steps.sh "${steps.tool 'Maven'}/bin/mvn -o ${args}"
  }
}
</code></pre>

<pre><code class="groovy Example 2 (continued)">@Library('utils') 
import org.foo.Utilities

def utils = new Utilities(env, steps)
node {
  utils.mvn 'clean package'
}
</code></pre>

<p>In the final example, we can also use static method and pass in the <code>script</code> object, which already has access to everything, including environment variables <code>script.env</code> and Pipeline steps such as <code>script.sh</code>.</p>

<pre><code class="groovy Example 3">package org.demo
class Utilities {
  static def mvn(script, args) {
    script.sh "${script.tool 'Maven'}/bin/mvn -s ${script.env.HOME}/jenkins.xml -o ${args}"
  }
}
</code></pre>

<p>The above example shows the script being passed in to one static method, invoked from a Scripted Pipeline as follows (note <code>import static</code>):</p>

<pre><code class="groovy Example 3 (continued)">@Library('utils') 
import static org.demo.Utilities.*
node {
  mvn this, 'clean package'
}
</code></pre>

<h3>Recommended practices</h3>

<p>All three approaches shown in three examples above are valid in Scripted Jenkinsfile.
However, per <a href="https://youtu.be/M8U9RyL756U?list=PLvBBnHmZuNQLqgKDFmGnUClw68qsQ9Hq5&amp;t=2310">recommended</a> by <a href="https://www.slideshare.net/BrentLaster/2017-jenkins-world/36">CloudBees Inc.</a>, <code>src</code> folder is best for utility classes that contains a bunch of static Groovy methods.
It is easier to use global variables in the <code>vars</code> directory instead of classes in the <code>src</code> directory, especially when you need to support <strong>declarative</strong> pipelines in your team.
The reason is that in declarative pipelines, the custom functions in Jenkins shared libraries must be callable in declarative syntax, e.g., &ldquo;myCustomFunction var1, var2&rdquo; format.
As you can see in the examples above, only the last example, where custom functions are defined as static methods, the invocation of custom function is compatible with declarative pipeline syntax.</p>

<p>When using <code>src</code> area&rsquo;s Groovy codes with <code>library</code> step, you should use a temporary variable to reduce its verbosity, as follows:</p>

<pre><code class="groovy Reduce verbosity">def mvn = library('utils').org.demo.Utilities.mvn
mvn this, 'clean package'
// or 
// mvn self, 'clean package'
</code></pre>

<h3>Reference</h3>

<ul>
<li><a href="https://youtu.be/M8U9RyL756U?list=PLvBBnHmZuNQLqgKDFmGnUClw68qsQ9Hq5&amp;t=1576">Great Talk at Jenkins World 2017</a></li>
<li><a href="https://jenkins.io/doc/book/pipeline/shared-libraries/">Accessing Steps section in Jenkins Doc</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins Plugin Development]]></title>
    <link href="http://tdongsi.github.io/blog/2017/11/29/jenkins-plugin-development/"/>
    <updated>2017-11-29T07:47:17-08:00</updated>
    <id>http://tdongsi.github.io/blog/2017/11/29/jenkins-plugin-development</id>
    <content type="html"><![CDATA[<p>How to create a Jenkins plugin.</p>

<!--more-->


<h3>Basic plugin</h3>

<p>Reference:</p>

<ul>
<li><a href="https://github.com/MarkEWaite/hello-world-plugin/tree/jenkins-world-2017">Tutorial</a></li>
<li><a href="https://www.youtube.com/watch?feature=player_embedded&amp;v=azyv183Ua6U">Video</a></li>
</ul>


<h3>Pipeline plugin</h3>

<p>Reference:</p>

<ul>
<li><a href="https://github.com/jglick/wfdev/tree/pipeline">Tutorial</a></li>
<li><a href="https://github.com/jglick/wfdev/blob/master/preso.pdf">Slides</a></li>
<li><a href="https://github.com/jenkinsci/pipeline-plugin/blob/master/DEVGUIDE.md">Developer&rsquo;s guide</a></li>
</ul>


<h3>Blue Ocean plugin</h3>

<pre><code class="plain Local development of Blue Ocean plugin"># this will build and run the plugin in local Jenkins
mvn install hpi:run
# this will recompile js &amp; less while editing
npm run bundle:watch
</code></pre>

<p><strong><em>Gotcha</em></strong>: extension changes won&rsquo;t update without a Jenkins restart.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins World 2017]]></title>
    <link href="http://tdongsi.github.io/blog/2017/08/29/jenkins-world-2017/"/>
    <updated>2017-08-29T08:47:04-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/08/29/jenkins-world-2017</id>
    <content type="html"><![CDATA[<p>Some interesting talks in <a href="https://www.cloudbees.com/jenkinsworld/schedule">Jenkins World 2017</a> are summarized in this blog post.</p>

<!--more-->


<h3>Jenkins Pipeline on your Local Box to Reduce Cycle Time</h3>

<p>Interesting proposal (with <strong>demo</strong>, a big plus) to resolve the following problems (added my own experience):</p>

<ul>
<li>Non repeatble builds due to allocated physical slaves with reused workspaces.

<ul>
<li>The idea is equivalent to use Dockerized Jenkins for local job runs before running on central Jenkins.</li>
<li>My current alternative is to use containerized Jenkins slaves using Kubernetes plugin.</li>
</ul>
</li>
<li>Merging of two companies (YNAP + GerritForge)

<ul>
<li>Not applicable. However, for large corporates, two product teams can feel like two companies.</li>
</ul>
</li>
<li>Need for fast feedback

<ul>
<li>Same</li>
</ul>
</li>
<li>One master cannot suit all: central CI not flexible to local team needs.

<ul>
<li>Maybe applicable for team CI and company-wide CI.</li>
</ul>
</li>
<li>Scalability: central CI only handle <code>master</code> job runs instead of multiple feature job runs.</li>
</ul>


<p>Reference:</p>

<ul>
<li><a href="https://github.com/NET-A-PORTER/jenkinsworld-2017-sample-app">Code repo</a></li>
</ul>


<pre><code class="groovy default Jenkinsfile">#!/bin/env groovy

node {
    checkout scm

    echo env.JENKINS_URL
    if(env.JENKINS_URL ==~ /.*central-pipeline.*/) {
        echo "loading central"
        load "central/Jenkinsfile"
    } else {
        echo "loading local"
        load "local/Jenkinsfile"
    }
}()
</code></pre>

<pre><code class="groovy local Jenkinsfile">{ -&gt; docker.image('slave-sbt').inside 
    {
        stage('Build') {
            sh sbt('compile')
        }
        stage('Test') {
            sh sbt('test')
        }
        stage('Deploy Locally') {
            sh sbt('docker:publishLocal')

            def dockerTag = (sh(script: "git describe --tags HEAD", returnStdout: true)).trim()
            cleanUpOldContainers(dockerTag)
            runContainer(dockerTag)

            def containerUrl = getRunningContainerURL(dockerTag)

            echo "Running on $containerUrl"
            currentBuild.setDescription("$containerUrl")


        }

        stage('Push to GitHub') {
            withCredentials([[$class: 'UsernamePasswordMultiBinding',
                              credentialsId: 'github',
                              usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD']]) {
                sh "git branch --list ${env.BRANCH_NAME} || git checkout -b ${env.BRANCH_NAME}"
                sh "git push -f https://$USERNAME:$PASSWORD@github.com/NET-A-PORTER/jenkinsworld-2017-sample-app HEAD:refs/heads/${env.BRANCH_NAME}"
            }
        }
    }
}

...
</code></pre>

<pre><code class="groovy central Jenkinsfile">{ -&gt; docker.image('slave-sbt').inside
    {
        stage('Build') {
                sh sbt('compile')
        }
        stage('Creating Docker container') {
                sh sbt('docker:stage')
        }
        if (env.BRANCH_NAME == "master") {
            stage('Deploy to Heroku') {
                withCredentials([[$class: 'UsernamePasswordMultiBinding',
                                  credentialsId: 'heroku',
                                  usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD']]) {
                    sh "echo 'machine git.heroku.com login $USERNAME password $PASSWORD' &gt; ~/.netrc"
                    sh "chmod 600 ~/.netrc"
                    sh "git push -f https://git.heroku.com/jenkinsworld-2017-sample-app.git HEAD:master"
                }
            }
        }
    }
}

def sbt(target) {
    return "sbt -no-colors $target"
}
</code></pre>

<h3>Managing Jenkins with CloudBees Jenkins Team</h3>

<p>CloudBees Jenkins is the Enterprise version of Jenkins, as opposed to Open-Source Jenkins.
This enterprise version offers the following features:</p>

<ul>
<li>Beekeeper Upgrade Assistant: Plugin upgrade compatibility, Compliance report.</li>
<li>Upgrade simulations to make sure the upgrade is compatible with current jobs/plugins.</li>
</ul>


<p>Like many other tools presented in the conference, you can do many &ldquo;awesome&rdquo; things <strong>IF</strong> you pay for it.
The only problem is if you have the budget to pay for it.</p>

<h3>Let&rsquo;s build a Jenkins Pipeline</h3>

<p>Basic tutorial on Jenkinsfile with Declarative syntax.
Not that interesting if you are already familiar with Jenkinsfile.</p>

<ul>
<li><a href="https://www.slideshare.net/secret/5d85kTqLfjOgdC">Slides</a></li>
<li><a href="https://gist.github.com/ericlong/25fd60f197f6c4c7b8f265af7a351e75">Code snippets</a></li>
</ul>


<h3>Developing Pipeline Libraries Locally</h3>

<p>If you have ever tried developing Pipeline Libraries, you may have noticed how long it takes to deploy a new version to server to discover just another syntax error. Oleg will show how to edit and test Pipeline libraries locally before committing to the repository (with Configuration-as-Code and Docker).</p>

<ul>
<li><a href="https://hub.docker.com/r/onenashev/demo-jenkins-config-as-code/">DockerHub repo</a></li>
<li><a href="https://github.com/oleg-nenashev/demo-jenkins-config-as-code">Github repo</a></li>
</ul>


<!-- Photos:
IMG_1097
IMG_1098
IMG_1099
-->


<h3>Securing a Jenkins Instance</h3>

<p>See <a href="/blog/2017/09/05/securing-jenkins-with-nginx/">this post</a>.</p>

<!-- Photos:
IMG_[1100..1107]
-->


<h3>Plugin Development for Pipeline</h3>

<p>See <a href="/blog/2017/08/29/jenkins-plugin-development/">Pipeline plugin development</a>.</p>

<h3>Extending Blue Ocean</h3>

<p>See <a href="/blog/2017/08/29/jenkins-plugin-development/">Blue Ocean plugin development</a>.</p>

<!-- Photos:
IMG_[1110..1116]
-->


<h3>Scaling Jenkins with Kubernetes</h3>

<p>We are already using Kubernetes plugin in production.
The talk mostly recaps how to use the plugin.</p>

<ul>
<li><a href="https://github.com/jenkinsci/kubernetes-plugin/tree/master/examples">Examples</a>

<ul>
<li>Interesting examples include <a href="https://github.com/jenkinsci/kubernetes-plugin/blob/master/examples/multi-container.groovy">multi-container</a>, <a href="https://github.com/jenkinsci/kubernetes-plugin/blob/master/examples/selenium.groovy">selenium</a>.</li>
</ul>
</li>
</ul>


<!-- Photos:
IMG_[1117..1121]
-->


<h3>Declarative Pipelines in Jenkins</h3>

<p>New features and improvements in Declarative Jenkinsfile are announced.
Those include:</p>

<ul>
<li><code>changelog</code>: examines the commit log messages with a regular expression.</li>
<li><code>changeset</code>: the affected file paths in the changelog.</li>
</ul>


<!-- Photos:
IMG_[1123..1134]
-->


<h3>Codifying the Build and Release Process with a Jenkins Pipeline Shared Library</h3>

<p>Almost all of the Jenkins workflows practiced at FireEye are already implemented in our Jenkins.
It&rsquo;s assuring to know that we are using the best practices and not way behind the pack.
However, I got a glimpse of potential struggles (mostly from inertia) migrating from a legacy Jenkins system (1.x) to Jenkinsfile-based system (2.x).</p>

<!-- Photos:
IMG_[1135..1138]
-->




<!-- Pimp my Blue Ocean
Photos:
IMG_[1139..1144]
-->


<h3>Mozilla’s Declarative + Shared Libraries Setup</h3>

<p>How Mozilla is using <strong>Declarative</strong> Pipelines and shared libraries together.</p>

<ul>
<li><a href="https://github.com/mozilla/fxtest-jenkins-pipeline">Github repo</a></li>
<li><a href="https://github.com/mozilla/mozillians-tests/blob/master/Jenkinsfile">Example Jenkinsfile</a></li>
</ul>


<!-- Photos:
IMG_[1145..1150]
-->


<h3>Pipelines At Scale: How Big, How Fast, How Many?</h3>

<p>Interesting point: Each pipeline step is similar to a database transaction: each step requires an atomic record in case of Jenkins restart.
Therefore, it is better to have a large enough transaction than multiple small transactions (e.g., <code>sh</code> step).</p>

<p>For comprehensive study of this topic (Jenkins performance), there are many articles/blog posts written by same author (Sam Van Oort).</p>

<!-- Photos:
IMG_[1151..1163]
-->


<h3>JenkinsPipelineUnit: Test your Continuous Delivery Pipeline</h3>

<p>JenkinsPipelineUnit allows unit testing the Jenkinsfile locally by mocking the Pipeline steps.
In my opinion, it seems only useful for reducing the <strong>syntax</strong> mistakes when developing Jenkinsfile OR global shared library.
You still have to verify functionality in a real Jenkins system.
Its compatibility with Declarative syntax is also questionable, admitted by the speakers/authors.
In addition, it is NOT for developling a Jenkins plugin. In that case, use JenkinsRule.</p>

<ul>
<li><a href="https://github.com/lesfurets/JenkinsPipelineUnit">Github repo</a></li>
</ul>


<!-- Photos:
IMG_[1164..1170]
-->


<h3>Securing a Jenkins Instance</h3>

<p>Demo &ldquo;Securing a Jenkins Instance&rdquo; at Jenkins Booth in Jenkins World 2017 by Claudiu Guiman.</p>

<p><blockquote><p>A set of minimum steps every Jenkins Admin should follow so his public-facing Jenkins instance doesn’t turn into a Bitcoin mine.</p></blockquote></p>

<pre><code class="plain nginx configuration">server {
    listen 80;
    server_name demo-001.eastus.cloudapp.azure.com;
    location / {
        proxy_set_header        Host $host:$server_port;
        proxy_set_header        X-Real-IP $remote_addr;
        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header        X-Forwarded-Proto $scheme;
        proxy_pass              http://localhost:8080;
        proxy_redirect          http://localhost:8080 http://demo-001.eastus.cloudapp.azure.com;
        proxy_read_timeout      90;
    }

    # block requests to /cli
    location /cli {
        deny all;
    }

    # block requests to /login
    location ~ /login* {
        deny all;
    }
}
</code></pre>

<pre><code class="plain Running nginx">$ cp ~/demo/default /etc/nginx/sites-enabled/default
$ sudo service nginx restart
$ sudo ufw deny 8080
</code></pre>

<p>If your Jenkins is hosted in AWS/Google Cloud, you should consider setting this up.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DSL Implementation in Groovy]]></title>
    <link href="http://tdongsi.github.io/blog/2017/08/13/groovy-dsl/"/>
    <updated>2017-08-13T15:18:30-07:00</updated>
    <id>http://tdongsi.github.io/blog/2017/08/13/groovy-dsl</id>
    <content type="html"><![CDATA[<p>Domain-Specific Language is a mini language for a specific problem and/or in a narrow context.
For example, internally used automation tools usually define some small DSL for configuration and most users understand the context and what DSL offers.</p>

<p>This blog post offers my simplistic view of how an internal DSL is implemented in Groovy via closure delegation.
It shows the progression from standard Java-like implementation -> its fluent version -> final DSL form.
This might help undrestanding the inner workings of a DSL such as Jenkins&rsquo;s Pipeline steps.
There are probably more advanced methods/frameworks for creating DSL.
However, those are not in the scope of this post.</p>

<!--more-->


<h3>Example DSL</h3>

<p>We want to implement a simple DSL that is similar to <a href="https://jenkins.io/doc/pipeline/steps/">Pipeline steps in Jenkinsfile</a>.</p>

<pre><code class="plain DSL in Jenkinsfile">{
    withEnv("PATH=/usr/bin")
    echo("Starting pipeline")
    sh("ls .")
    error("Error here")
}
</code></pre>

<p>In this DSL example, users will write a sequence of steps using a small, pre-defined set of custom statements such as <code>echo</code> and <code>sh</code> above.
For each step in the DSL, the backend classes and objects will perform some execution in the background, using the relevant context specific to the domain (e.g., Jenkins domain).
For simplicity, <code>println</code> statements will be used in the following examples.</p>

<p>The advantage of DSL is that the <strong>developers</strong> can implement the backend in some fully-featured language such as Java but the <strong>users</strong> don&rsquo;t need to know such language to use it.
Such a separation is common in DevOps and automation frameworks where the users want the flexibility of configuring based on their needs but don&rsquo;t want to get exposed to the implementation details (which are usually ugly and compplicated).
Instead, the <strong>users</strong> only need to learn the DSL to use it while still have the flexibility to do what they want.
One example can be found in data science domain where data scientists are usually more comfortable developing in R or SQL but automated deployment frameworks or tools can be in another language such as Java.</p>

<h3>Version 1: Java-like standard implementation</h3>

<p>First, we show a standard implementation in Java to show how backend execution can be implemented.
In the advanced versions, the difference is only in its public interface to make it more user-friendly but the backend execution will be similar.</p>

<pre><code class="groovy Standard Java implementation">/**
 * Java code with standard implementation
 * Try to simulate some kind of DSL like Pipeline steps in Jenkins
 */
class JavaDsl {

    void echo(String message) {
        println "Echo: $message";
    }

    void sh(String script) {
        println "Shell: $script";
    }

    void error(String message) {
        println "Error here: $message";
    }

    // A more advanced DSL
    void withEnv(String var) {
        println "Using: $var";
    }

    void execute() {
        println "Executing ...";
    }

}

println "1) Standard Java implementation";
JavaDsl javaDsl = new JavaDsl();
javaDsl.withEnv("PATH=/usr/bin");
javaDsl.echo("Starting pipeline");
javaDsl.sh("ls .");
javaDsl.error("Error here");
javaDsl.execute();
println "";
</code></pre>

<p>The problem of this approach is that users have to write Java (or Groovy) code directly to use it.</p>

<h3>Version 2: Fluent interface with Builder pattern</h3>

<pre><code class="groovy Fluent Java implementation">/**
 * Java code with Builder pattern
 * Try to simulate some kind of DSL like Pipeline steps in Jenkins
 */
class JavaBuilderDsl {

    JavaBuilderDsl echo(String message) {
        println "Echo: $message"
        return this
    }

    JavaBuilderDsl sh(String script) {
        println "Shell: $script"
        return this
    }

    JavaBuilderDsl error(String message) {
        println "Error here: $message"
        return this
    }

    // A more advanced DSL
    JavaBuilderDsl withEnv(String var) {
        println "Using: $var"
        return this
    }

    void execute() {
        println "Executing ..."
    }
}

println "2) Fluent Java implementation (Builder)"
JavaBuilderDsl builderDsl = new JavaBuilderDsl()
builderDsl.withEnv("PATH=/usr/bin")
        .echo("Starting pipeline")
        .sh("ls .")
        .error("Error here")
        .execute()
println ""
</code></pre>

<p>In this version, the code is fluent with the object name <code>builderDsl</code> not being repeated every single line.
As a result, the code is less verbose and much more user-friendly.</p>

<h3>Version 3: DSL with Groovy closure</h3>

<pre><code class="groovy Standard Groovy implementation">/**
 * Groovy code with standard implementation
 * Try to simulate some kind of DSL like Pipeline steps in Jenkins
 */
class GroovyDsl {

    def echo(String message) {
        println "Echo: $message"
    }

    def sh(String script) {
        println "Shell: $script"
    }

    def error(String message) {
        println "Error here: $message"
    }

    // A more advanced DSL
    def withEnv(String var) {
        println "Using: $var"
    }

    static void execute(closure) {
        GroovyDsl body = new GroovyDsl()
        closure(body)
        println "Executing ..."
    }

}

println "3) Standard Groovy implementation"
GroovyDsl.execute { dsl -&gt;
    dsl.withEnv("PATH=/usr/bin")
    dsl.echo("Starting pipeline")
    dsl.sh("ls .")
    dsl.error("Error here")
}
println ""
</code></pre>

<p>This first version of Groovy implementation is presented here to show connection with its Java counterparts.
As shown below, the input variable <code>dsl</code> in the closure can be abstracted away using delegate.</p>

<pre><code class="groovy Transparent DSL with delegate">class GroovyDsl {

    def echo(String message) {
        println "Echo: $message"
    }

    def sh(String script) {
        println "Shell: $script"
    }

    def error(String message) {
        println "Error here: $message"
    }

    // A more advanced DSL
    def withEnv(String var) {
        println "Using: $var"
    }

    static void execute(Closure closure) {
        GroovyDsl body = new GroovyDsl()
        // TRICKY: Modify the input var? Hmmm.
        closure.delegate = body
        closure()
        println "Executing ..."
    }

    static void executeBest(Closure closure) {
        GroovyDsl body = new GroovyDsl()
        body.with(closure)
        println "Executing ..."
    }

}

println "4) DSL-style Groovy implementation"
GroovyDsl.execute {
    withEnv("PATH=/usr/bin")
    echo("Starting pipeline")
    sh("ls .")
    error("Error here")
}
println ""

println "4b) DSL-style Groovy (better) implementation"
GroovyDsl.executeBest {
    withEnv("PATH=/usr/bin")
    echo("Starting pipeline")
    sh("ls .")
    error("Error here")
}
println ""
</code></pre>

<p>In this final version, only a very small boiler-plate code <code>GroovyDsl.executeBest</code> remains.
The following lines form a mini language (i.e., DSL) that can be exposed to users.
The users can start using the DSL without having to learn Groovy or Java.</p>

<p>Note that the <code>executeBest</code> is the equivalent but less straight-forward way to do the same thing with delegate.
Compared with <code>execute</code>, it has the benefit of NOT modifying the input reference <code>closure</code>.</p>

<h3>Reference</h3>

<ul>
<li><a href="http://groovy-lang.org/closures.html">Groovy closure</a></li>
<li><a href="https://jenkins.io/doc/pipeline/steps/">Jenkins pipeline steps</a></li>
<li><a href="https://dzone.com/articles/groovy-dsl-simple-example">Another example Groovy implementation</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
